<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How Query Engines Work 中文版</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">译者注</a></li><li class="chapter-item expanded affix "><a href="00-acknowledgments.html">致谢</a></li><li class="chapter-item expanded affix "><a href="00-introduction.html">简介</a></li><li class="chapter-item expanded "><a href="01-what-is-a-query-engine.html"><strong aria-hidden="true">1.</strong> 什么是查询引擎？</a></li><li class="chapter-item expanded "><a href="02-apache-arrow.html"><strong aria-hidden="true">2.</strong> Apache Arrow</a></li><li class="chapter-item expanded "><a href="03-type-system.html"><strong aria-hidden="true">3.</strong> 类型系统</a></li><li class="chapter-item expanded "><a href="04-data-sources.html"><strong aria-hidden="true">4.</strong> 数据源</a></li><li class="chapter-item expanded "><a href="05-logical-plan.html"><strong aria-hidden="true">5.</strong> 逻辑计划</a></li><li class="chapter-item expanded "><a href="06-dataframe.html"><strong aria-hidden="true">6.</strong> 数据帧</a></li><li class="chapter-item expanded "><a href="07-physical-plan.html"><strong aria-hidden="true">7.</strong> 物理计划</a></li><li class="chapter-item expanded "><a href="08-query-planner.html"><strong aria-hidden="true">8.</strong> 查询规划器</a></li><li class="chapter-item expanded "><a href="09-optimizations.html"><strong aria-hidden="true">9.</strong> 查询优化器</a></li><li class="chapter-item expanded "><a href="10-execution.html"><strong aria-hidden="true">10.</strong> 查询执行</a></li><li class="chapter-item expanded "><a href="11-sql-support.html"><strong aria-hidden="true">11.</strong> SQL 支持</a></li><li class="chapter-item expanded "><a href="12-parallel-query.html"><strong aria-hidden="true">12.</strong> 执行并行查询</a></li><li class="chapter-item expanded "><a href="13-distributed-query.html"><strong aria-hidden="true">13.</strong> 执行分布式查询</a></li><li class="chapter-item expanded "><a href="14-testing.html"><strong aria-hidden="true">14.</strong> 测试</a></li><li class="chapter-item expanded "><a href="15-benchmarks.html"><strong aria-hidden="true">15.</strong> 基准测试</a></li><li class="chapter-item expanded "><a href="16-further-resources.html"><strong aria-hidden="true">16.</strong> 更多资源</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">How Query Engines Work 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/hengfeiyang/how-query-engines-work-zh-CN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-query-engines-work-中文版"><a class="header" href="#how-query-engines-work-中文版">How Query Engines Work 中文版</a></h1>
<p>阅读地址：<a href="https://hengfeiyang.github.io/how-query-engines-work-zh-CN/">https://hengfeiyang.github.io/how-query-engines-work-zh-CN/</a></p>
<p>英文原版：<a href="https://howqueryengineswork.com/">https://howqueryengineswork.com/</a></p>
<p>作者主页：<a href="https://andygrove.io/how-query-engines-work/">https://andygrove.io/how-query-engines-work/</a></p>
<p>原文许可：Copyright © 2020-2023 Andy Grove. All rights reserved</p>
<p>译文许可：Creative Commons Attribution-ShareAlike 4.0 International License</p>
<blockquote>
<p>该翻译项目已获得原作者 <a href="https://www.linkedin.com/in/andygrove/">Andy Grove</a> 授权许可</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="致谢"><a class="header" href="#致谢">致谢</a></h1>
<p>如果没有我家人的支持，这本书是不可能完成的，当我专注于又一个业余项目时，他们对我非常有耐心。</p>
<p>特别感谢马修·鲍尔斯（Matthew Powers），也就是Mr. Powers，是他首先激励我写这本书。Matthew 是《Writing Beautiful Apache Spark Code》一书的作者，该书也可以在 <a href="https://leanpub.com/beautiful-spark/">Leanpub</a> 上找到。</p>
<p>我还需要感谢过去几年在我从事 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 项目时与我互动的无数人，特别是 Apache Arrow PMC、提交者和贡献者。</p>
<p>最后，我要感谢 Chris George 和 Joe Buszkiewic 在 RMS 工作期间的支持和鼓励，在那里我进一步加深了对查询引擎的理解。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>自从开始我的第一份软件工程工作以来，我就对数据库和查询语言着迷。向计算机提出问题并有效地获取有意义的数据几乎像魔法一样。在多年作为通用软件开发者和数据技术终端用户的经验后，我开始在一家初创公司工作，这让我深入到了分布式数据库开发的领域。当我开始这段旅程时，我多么希望这本书已经存在。虽然这只是一本入门级的书籍，但我希望能够揭开查询引擎如何工作的神秘面纱。</p>
<p>我对查询引擎的兴趣最终使我参与了 <a href="https://arrow.apache.org/">Apache Arrow</a> 项目，我在 2018 年捐赠了最初的 Rust 实现，然后在 2019 年捐赠了 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 内存查询引擎，最后在 2021 年捐赠了 <a href="https://github.com/apache/arrow-ballista">Ballista</a> 分布式计算项目. 我不打算再构建 Arrow 项目之外的任何其他东西，并且现在我将继续为 Arrow 中的这些项目做出贡献。</p>
<p>Arrow 项目现在有许多活跃的提交者和贡献者致力于 Rust 实现，与我最初的贡献相比，已经有了显著的改进。</p>
<p>尽管 Rust 是高性能查询引擎的绝佳选择，但它并不适合教授查询引擎的相关概念，因此我在编写本书时使用 Kotlin 构建了一个新的查询引擎。Kotlin 是一种非常简洁且易于阅读的语言，使得可以在本书中包含源代码示例。我鼓励您在阅读本书时熟悉源代码，并考虑做出一些贡献。没有比动手实践更好的学习方法了！</p>
<p>本书中介绍的查询引擎最初打算作为 <a href="https://github.com/apache/arrow-ballista">Ballista</a> 项目（并曾经是）的一部分，但随着项目的发展，显然将查询引擎保留在 Rust 中并通过 UDF 机制支持 Java 和其他语言，而不是在多种语言中复制大量的查询执行逻辑更有意义。</p>
<p>现在 <a href="https://github.com/apache/arrow-ballista">Ballista</a> 已捐赠给 <a href="https://arrow.apache.org/">Apache Arrow</a>，我已经更新了本书，将配套存储库中的查询引擎简称为“KQuery”，是 Kotlin 查询引擎的缩写，但如果有人有更好的名称建议，请告诉我！</p>
<p>本书内容更新将免费提供，请偶尔回来查看或者关注我的 Twitter (@andygrove_io) 以便在有新内容是收到通知。</p>
<h2 id="反馈"><a class="header" href="#反馈">反馈</a></h2>
<p>如果您对这本书有任何反馈，请通过 Twitter @andygrove_io 向我发送私信或发送电子邮件至 agrove@apache.org。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是查询引擎"><a class="header" href="#什么是查询引擎">什么是查询引擎？</a></h1>
<p>查询引擎是一种软件，可以对数据执行查询以生成问题的答案，例如：</p>
<ul>
<li>今年到目前为止，我的月平均销售额是多少？</li>
<li>过去一天我网站上最受欢迎的五个网页是什么？</li>
<li>与上一年相比，每月的网站流量如何？</li>
</ul>
<p>最广泛使用的查询语言是<a href="https://en.wikipedia.org/wiki/SQL">结构化查询语言</a>（简称SQL）。许多开发人员在其职业生涯的某个阶段都会遇到过关系数据库，例如 MySQL、Postgres、Oracle 或 SQL Server。所有这些数据库都包含支持 SQL 的查询引擎。</p>
<p>以下是一些 SQL 查询示例。</p>
<p><em>SQL 示例：月平均销售额</em></p>
<pre><code class="language-sql">SELECT month, AVG(sales)
FROM product_sales
WHERE year = 2020
GROUP BY month;
</code></pre>
<p><em>SQL 示例：昨天排名前 5 的网页</em></p>
<pre><code class="language-sql">SELECT page_url, COUNT(*) AS num_visits
FROM apache_log
WHERE event_date = yesterday()
GROUP BY page_url
ORDER BY num_visits DESC
LIMIT 5;
</code></pre>
<p>SQL 功能强大且被广泛理解，但在所谓的“大数据”世界中存在局限性，数据科学家通常需要将自定义代码与其查询混合在一起。现在，Apache Hadoop、Apache Hive 和 Apache Spark 等平台和工具现在广泛用于查询和操作海量数据。</p>
<p>以下示例演示了如何使用 Apache Spark 对 Parquet 数据集执行简单的聚合查询。Spark 的真正强大之处在于，该查询可以在笔记本电脑或数百台服务器的集群上运行，而无需更改代码。</p>
<p><em>Apache Spark 使用 DataFrame 查询示例</em></p>
<pre><code class="language-scala">val spark: SparkSession = SparkSession.builder
  .appName("Example")
  .master("local[*]")
  .getOrCreate()

val df = spark.read.parquet("/mnt/nyctaxi/parquet")
  .groupBy("passenger_count")
  .sum("fare_amount")
  .orderBy("passenger_count")

df.show()
</code></pre>
<h2 id="为什么查询引擎这么流行"><a class="header" href="#为什么查询引擎这么流行">为什么查询引擎这么流行？</a></h2>
<p>数据正以前所未有的速度增长，并且往往无法仅存储在单台计算机上。编写用于查询数据的分布式代码需要专业工程技能，并且每次需要从数据中获取新答案时都编写定制代码是不现实的。</p>
<p>查询引擎提供了一组标准操作和转换，最终用户可以通过简单的查询语言或应用程序编程接口以不同方式组合使用，并且调优以获得良好性能。</p>
<h2 id="本书内容概述"><a class="header" href="#本书内容概述">本书内容概述</a></h2>
<p>本书提供了构建通用查询引擎所涉及的每个步骤的概览。</p>
<p>本书中讨论的查询引擎是专门为本书开发的简单查询引擎，代码是在编写本书内容的同时开发的，以确保我可以在面临设计决策时编写有关主题的内容。</p>
<h2 id="源代码"><a class="header" href="#源代码">源代码</a></h2>
<p>本书中讨论的查询引擎的完整源代码位于以下 GitHub 存储库中。</p>
<pre><code>https://github.com/andygrove/how-query-engines-work
</code></pre>
<p>请参阅项目中的README，获取使用Gradle构建项目的最新指南。</p>
<h2 id="为什么使用-kotlin"><a class="header" href="#为什么使用-kotlin">为什么使用 Kotlin？</a></h2>
<p>本书的重点是查询引擎设计，这通常与编程语言无关。我之所以为这本书选择Kotlin，是因为它简洁易懂。它还与 Java 100% 兼容，这意味着您可以从 Java 和其他基于 Java 的语言（例如 Scala）调用 Kotlin 代码。</p>
<p>然而，Apache Arrow项目中的DataFusion查询引擎也主要基于本书的设计。对Rust比JVM更感兴趣的读者可以结合本书参考DataFusion源码。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-arrow"><a class="header" href="#apache-arrow">Apache Arrow</a></h1>
<p>Apache Arrow 最初是作为列式数据内存格式的规范而开始的，并以 Java 和 C++ 实现。这种内存格式对于在支持 SIMD（单指令，多数据）的现代硬件如 CPU 和 GPU 上进行向量化处理非常高效。</p>
<p>采用标准化的内存数据格式有几个好处：</p>
<ul>
<li>Python 或 Java 等高级语言可以通过传递指向数据的指针而不是以不同的格式复制数据（这将非常贵）来调用 Rust 或 C++ 等低级语言来执行计算密集型任务。</li>
<li>数据可以在进程之间有效地传输，而无需大量序列化开销，因为内存格式也是网络格式（尽管数据也可以被压缩）。</li>
<li>它应该使在数据科学和数据分析领域的各种开源和商业项目之间构建连接器、驱动程序和集成变得更加容易，并允许开发人员使用他们最喜欢的语言来利用这些平台。</li>
</ul>
<p>Apache Arrow 现在有多种编程语言的实现，包括 C、C++、C#、Go、Java、JavaScript、Julia、MATLAB、Python、R、Ruby 和 Rust。</p>
<h2 id="arrow-内存模型"><a class="header" href="#arrow-内存模型">Arrow 内存模型</a></h2>
<p><a href="https://arrow.apache.org/docs/format/Columnar.html">Arrow 网站</a> 上详细描述了内存模型，但本质上每一列都由保存原始数据的单个向量表示，以及表示空值和可变宽度类型的原始数据偏移量的单独向量。</p>
<h2 id="进程间通信ipc"><a class="header" href="#进程间通信ipc">进程间通信（IPC）</a></h2>
<p>正如我之前提到的，可以通过传递指向数据的指针来在进程之间传递数据。然而，接收进程需要知道如何解释这些数据，因此定义了 IPC 格式来交换元数据，例如结构信息。Arrow 使用 Google Flatbuffers 来定义元数据格式。</p>
<h2 id="计算核心"><a class="header" href="#计算核心">计算核心</a></h2>
<p>Apache Arrow 的范围已经扩展到为评估表达式提供计算库。Java、C++、C、Python、Ruby、Go、Rust 和 JavaScript 实现包含了用于在 Arrow 内存上执行计算的计算库。</p>
<p>由于本书主要涉及 Java 实现，值得一提的是 <a href="https://www.dremio.com/">Dremio</a> 最近捐赠了 <a href="https://github.com/apache/arrow/tree/main/cpp/src/gandiva">Gandiva</a>，这是一个将表达式编译为 LLVM 并支持 SIMD 的 Java 库。JVM 开发人员可以将操作委托给 <a href="https://github.com/apache/arrow/tree/main/cpp/src/gandiva">Gandiva</a> 库，并从 Java 本身无法实现的性能提升中获益。</p>
<h2 id="arrow-flight-协议"><a class="header" href="#arrow-flight-协议">Arrow Flight 协议</a></h2>
<p>最近，Arrow 定义了一种用于高效地在网络上流式传输 Arrow 数据的 <a href="https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/">Flight</a> 协议，Flight 协议基于 <a href="https://grpc.io/">gRPC</a> 和 <a href="https://protobuf.dev/">Google Protocol Buffers</a>。</p>
<p>Flight 协议定义了一个 FlightService，具有以下方法：</p>
<h3 id="handshake"><a class="header" href="#handshake">Handshake</a></h3>
<p>客户端和服务端之间的握手。根据服务端的不同，可能需要握手来确定应用于未来操作的 Token。根据验证机制请求和响应都是允许多次往返的数据流。</p>
<h3 id="listflights"><a class="header" href="#listflights">ListFlights</a></h3>
<p>给定特定条件获取可用流列表。大多数 flight 服务都会公开一个或多个可供检索的流。此 API 允许列出可供使用的流。用户还可以提供条件，这些条件可以限制可以通过此接口列出的流的子集。每个 flight 服务都允许自己定义如何使用的条件。</p>
<h3 id="getflightinfo"><a class="header" href="#getflightinfo">GetFlightInfo</a></h3>
<p>对于给定的 FlightDescriptor，获取有关如何使用 flight 的信息。如果接口的消费者已经可以识别要使用的特定 flight，那么这是一个有用的接口。该接口还可以允许消费者通过指定的 descriptor 生成 flight 流。例如，一个 flight descriptor 可能包含将执行的 SQL 语句或 <a href="https://docs.python.org/3/library/pickle.html">Pickled Python</a> 操作。在这些情况下，之前在 ListFilghts 可用流列表中未提供的流，反而在特定的 Flight 服务定义的期间可用。</p>
<h3 id="getschema"><a class="header" href="#getschema">GetSchema</a></h3>
<p>对于给定的 FlightDescriptor，获取在 Schema.fbs::Schema 中描述的结构。当消费者需要 flight 流的结构时使用此功能。与 GetFlightInfo 类似，此接口可能会生成一个以前在 ListFlights 中不可用的新 flight。</p>
<h3 id="doget"><a class="header" href="#doget">DoGet</a></h3>
<p>检索与引用 ticket 相关的特定描述符所关联的单个流。一个 Flight 可以由一个或多个流组成，其中每个流都可以使用一个独立的 Flight 服务用来管理数据流集合的 opaque ticket 进行检索。</p>
<h3 id="doput"><a class="header" href="#doput">DoPut</a></h3>
<p>将流推送到与特定 flight 流关联的 flight 服务。这允许 flight 服务的客户端上传数据流。根据特定的 flight 服务，可以允许客户端消费者上传每个描述符的单个流或无限数量的流。后者，服务可能会实现 “seal” 操作，一旦所有流都上传完毕，该操作就可以应用于描述符。</p>
<h3 id="doexchange"><a class="header" href="#doexchange">DoExchange</a></h3>
<p>为给定描述符打开双向数据通道。这允许客户端在单个逻辑流中发送和接收任意 Arrow 数据和应用程序的特定元数据。与 DoGet/DoPut 相比，这更适合客户端将计算（而不是存储）卸载到 Flight 服务。</p>
<h3 id="doaction"><a class="header" href="#doaction">DoAction</a></h3>
<p>除了可能可用的 ListFlights、GetFlightInfo、DoGet、DoPut 操作之外， flight 服务还可以支持任意数量的简单操作。DoAction 允许 flight 客户端针对 flight 服务执行特定操作。一个操作包括特定于正在执行的操作类型的不透明请求和响应对象。</p>
<h3 id="listactions"><a class="header" href="#listactions">ListActions</a></h3>
<p>一个 flight 服务公开其所有可用操作类型及其描述。这使得不同的 flight 消费者能够了解 flight 服务的功能。</p>
<h2 id="arrow-flight-sql"><a class="header" href="#arrow-flight-sql">Arrow Flight SQL</a></h2>
<p>有人提议向 Arrow Flight 添加 SQL 功能。在撰写本文时（2021年1月），已经有一个针对 C++ 实现的 PR，跟踪问题为 <a href="https://issues.apache.org/jira/browse/ARROW-14698">ARROW-14698</a>。</p>
<h2 id="查询引擎"><a class="header" href="#查询引擎">查询引擎</a></h2>
<h3 id="datafusion"><a class="header" href="#datafusion">DataFusion</a></h3>
<p>Arrow 的 Rust 实现包含一个名为 DataFusion 的内存查询引擎，该引擎于 2019 年捐赠给该项目。该项目正在迅速成熟，并越来越受到关注。例如，InfluxData 正在利用 DataFusion 构建下一代 InfluxDB 的核心。</p>
<h3 id="ballista"><a class="header" href="#ballista">Ballista</a></h3>
<p>Ballista 是一个分布式计算平台，主要用 Rust 实现，并由 Apache Arrow 提供支持。它构建了一种架构允许其他编程语言（例如 Python、C++ 和 Java）作为一等公民而无需额外序列化成本。</p>
<p>Ballista 中的基础技术包括：</p>
<ul>
<li><strong>Apache Arrow</strong> 用于内存模型和类型系统。</li>
<li><strong>Apache Arrow Flight</strong> 协议用于进程间高效数据传输。</li>
<li><strong>Apache Arrow Flight SQL</strong> 协议供商业智能工具和JDBC驱动程序连接到 Ballista 集群。</li>
<li><strong>Google Protocol Buffers</strong>  用于序列化查询计划。</li>
<li><strong>Docker</strong> 用于打包执行器以及用户定义代码。</li>
<li><strong>Kubernetes</strong> 用于部署和管理执行器 docker 容器。</li>
</ul>
<p>Ballista 于 2021 年捐赠给 Arrow 项目，虽然能够以良好的性能运行流行的 TPC-H 基准测试中的大量查询，但尚未准备好投入生产使用。</p>
<h3 id="c-查询引擎"><a class="header" href="#c-查询引擎">C++ 查询引擎</a></h3>
<p>C++ 实现正在进行添加查询引擎的工作，当前的重点是实现高效的计算原语和数据集 API。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="选择一个类型系统"><a class="header" href="#选择一个类型系统">选择一个类型系统</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>datatypes</code> 模块中找到。</em></p>
<p>构建查询引擎的第一步是选择一个类型系统来表示查询引擎将要处理的不同类型的数据。一种选择是发明一种专门针对查询引擎的专有类型系统。另一种选择是使用查询引擎索要查询的数据源的类型系统。</p>
<p>如果查询引擎要支持查询多个数据源（通常是这种情况），那么每个支持的数据源和查询引擎的类型系统之间可能需要进行一些转换，因此使用一个能够代表所有支持的数据源的所有数据类型的类型系统将非常重要。</p>
<h2 id="基于行还是基于列"><a class="header" href="#基于行还是基于列">基于行还是基于列？</a></h2>
<p>一个重要的考虑因素是查询引擎将逐行处理数据还是以列式格式表示数据。</p>
<p>如今许多的查询引擎都是基于 <a href="https://paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf">Volcano Query Planner</a>，其在物理计划中每个步骤本质上都是对行进行迭代。这种模型易于实现，但在对数十亿行运行查询时往往会导致每行开销迅速增加。通过对数据进行批量迭代，可以减少这种开销。此外，如果这些批量数据以列的方式而不是行的方式表示数据，那么就可以使用 “向量化处理” 并利用 SIMD (单指令多数据) 的优势，用单条 CPU 指令处理一列中的多个值。这个概念还可以更进一步，利用 GPU 来并行处理更大量的数据。</p>
<h2 id="互操作性"><a class="header" href="#互操作性">互操作性</a></h2>
<p>另一个考虑因素是我们可能希望使我们的查询引擎可以通过多种编程语言访问。查询引擎的用户通常使用 Python、R 或 Java 等语言。我们可能还希望构建 ODBC 或 JDBC 驱动程序，以便轻松构建集成。</p>
<p>考虑到这些需求，最好找到一个行业标准来表示列式数据并高效地在进程之间交换这些数据。</p>
<p>我相信 Apache Arrow 提供了理想的基础，这一点可能并不奇怪。</p>
<h2 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h2>
<p>我们将使用 Apache Arrow 作为我们类型系统的基础。以下 Arrow 类用于表示结构、字段和数据类型。</p>
<ul>
<li><em>Schema</em> 为数据源或查询结果提供元数据，结构由一个或多个字段组成。</li>
<li><em>Field</em> 为结构中字段的名称和数据类型，并指定它是否允许空值。</li>
<li><em>FieldVector</em> 为字段数据提供列式存储。</li>
<li><em>ArrowType</em> 表示一种数据类型。</li>
</ul>
<p>KQuery 引入了一些额外的类和助手作为对 Apache Arrow 类型系统的抽象。</p>
<p>KQuery 为受支持的 Arrow 数据类型提供了可引用的常量。</p>
<pre><code class="language-kotlin">object ArrowTypes {
    val BooleanType = ArrowType.Bool()
    val Int8Type = ArrowType.Int(8, true)
    val Int16Type = ArrowType.Int(16, true)
    val Int32Type = ArrowType.Int(32, true)
    val Int64Type = ArrowType.Int(64, true)
    val UInt8Type = ArrowType.Int(8, false)
    val UInt16Type = ArrowType.Int(16, false)
    val UInt32Type = ArrowType.Int(32, false)
    val UInt64Type = ArrowType.Int(64, false)
    val FloatType = ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)
    val DoubleType = ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)
    val StringType = ArrowType.Utf8()
}
</code></pre>
<p>KQuery 并没有直接使用 <code>FieldVector</code>，而是引入了一个 <code>ColumnVector</code> 接口作为抽象，以提供更方便的访问方法，从而避免了为每种数据类型都使用特定的 <code>FieldVector</code> 实现。</p>
<pre><code class="language-kotlin">interface ColumnVector {
  fun getType(): ArrowType
  fun getValue(i: Int) : Any?
  fun size(): Int
}
</code></pre>
<p>这种抽象也使得标量值的实现成为可能，从而避免了用字面量为列中每个索引重复创建和填入 <code>FieldVector</code>。</p>
<pre><code class="language-kotlin">class LiteralValueVector(
    val arrowType: ArrowType,
    val value: Any?,
    val size: Int) : ColumnVector {

  override fun getType(): ArrowType {
    return arrowType
  }

  override fun getValue(i: Int): Any? {
    if (i&lt;0 || i&gt;=size) {
      throw IndexOutOfBoundsException()
    }
    return value
  }

  override fun size(): Int {
    return size
  }

}
</code></pre>
<p>KQuery 还提供了一个 <code>RecordBatch</code> 类来表示一批列式数据。</p>
<pre><code class="language-kotlin">class RecordBatch(val schema: Schema, val fields: List&lt;ColumnVector&gt;) {

  fun rowCount() = fields.first().size()

  fun columnCount() = fields.size

  /** Access one column by index */
  fun field(i: Int): ColumnVector {
      return fields[i]
  }

}
</code></pre>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据源"><a class="header" href="#数据源">数据源</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>datasource</code> 模块中找到。</em></p>
<p>查询引擎如果没有数据源可读取，那么它几乎无用武之地。我们希望能够支持多个数据源，因此创建一个接口让查询引擎能与数据源交互非常重要。这还允许用户将我们的查询引擎与他们的自定义数据源配合使用。数据源通常是文件或数据库，但也可以是内存中的对象。</p>
<h2 id="数据源接口"><a class="header" href="#数据源接口">数据源接口</a></h2>
<p>在查询计划阶段，了解数据源的结构非常重要，以便可以验证查询计划以确保引用的列存在并且数据类型与用于引用它们的表达式兼容。在某些情况下，结构可能不可用，因为某些数据源没有固定结构，通常称为“无结构（schema-less）”。 JSON 文档便是一种无结构数据源的例子。</p>
<p>在查询执行阶段，我们需要能够从数据源获取数据，并且需要能够指定将哪些列加载到内存中以提高效率。如果查询不涉及这些列，则没必要将其加载到内存中。</p>
<p><em>KQuery 数据源接口</em></p>
<pre><code class="language-kotlin">interface DataSource {

  /** Return the schema for the underlying data source */
  fun schema(): Schema

  /** Scan the data source, selecting the specified columns */
  fun scan(projection: List&lt;String&gt;): Sequence&lt;RecordBatch&gt;
}
</code></pre>
<h2 id="数据源示例"><a class="header" href="#数据源示例">数据源示例</a></h2>
<p>在数据科学或分析领域经常遇到许多数据源。</p>
<h3 id="逗号分隔值-csv"><a class="header" href="#逗号分隔值-csv">逗号分隔值 (CSV)</a></h3>
<p>CSV 文件是文本文件，每行一条记录，字段之间用逗号分隔，因此称为“逗号分隔值”。 CSV 文件不包含结构信息（文件第一行的可选列名称除外），尽管可以通过先读取文件来推导出结构，这可能是一项昂贵的操作。</p>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>JavaScript 对象表示法格式 (JSON) 是另一种流行的基于文本的文件格式。与 CSV 文件不同，JSON 文件是结构化的并且可以存储复杂的嵌套数据类型。</p>
<h3 id="parquet"><a class="header" href="#parquet">Parquet</a></h3>
<p>Parquet 旨在提供压缩、高效的列式数据表示，是 Hadoop 生态系统中流行的文件格式。Parquet 从一开始就考虑到了复杂的嵌套数据结构，并使用 Dremel 论文中描述的<a href="https://github.com/julienledem/redelm/wiki/The-striping-and-assembly-algorithms-from-the-Dremel-paper">record shredding and assembly algorithm</a> 算法构建。</p>
<p>Parquet 文件包含结构信息和批量存储的数据（称为“row groups”），其中每个批次若干列组成。<code>row groups</code> 可以包含压缩数据，还可以包含可选元数据，例如每列的最小值和最大值。查询引擎以使用此元数据来确定在扫描期间何时可以跳过某些 <code>row groups</code>。</p>
<h3 id="orc"><a class="header" href="#orc">Orc</a></h3>
<p>The Optimized Row Columnar (Orc) 优化行列 格式类似于 Parquet，数据以称为 “stripes” 的列式格式批量存储。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逻辑计划和表达式"><a class="header" href="#逻辑计划和表达式">逻辑计划和表达式</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>logical-plan</code> 模块中找到。</em></p>
<p>逻辑计划表示具有已知结构的关系（一组元组）。每个逻辑计划可以有零个或多个逻辑计划作为输入。逻辑计划可以很方便地公开其子计划，以便可以使用访问者模式来遍历该计划。</p>
<pre><code class="language-kotlin">interface LogicalPlan {
  fun schema(): Schema
  fun children(): List&lt;LogicalPlan&gt;
}
</code></pre>
<h2 id="打印逻辑计划"><a class="header" href="#打印逻辑计划">打印逻辑计划</a></h2>
<p>能够以人类可读形式打印逻辑计划对于帮助调试非常重要。逻辑计划通常打印为带有缩进子节点的分层结构。</p>
<p>我们可以实现一个简单的递归辅助函数来格式化逻辑计划。</p>
<pre><code class="language-kotlin">fun format(plan: LogicalPlan, indent: Int = 0): String {
  val b = StringBuilder()
  0.rangeTo(indent).forEach { b.append("\t") }
  b.append(plan.toString()).append("\n")
  plan.children().forEach { b.append(format(it, indent+1)) }
  return b.toString()
}
</code></pre>
<p>以下是使用此方法格式化逻辑计划的一个例子。</p>
<pre><code>Projection: #id, #first_name, #last_name, #state, #salary
  Filter: #state = 'CO'
    Scan: employee.csv; projection=None
</code></pre>
<h2 id="序列化"><a class="header" href="#序列化">序列化</a></h2>
<p>有时希望能够序列化查询计划，以便可以轻松地将它们转移到另一个进程。最好尽早添加序列化，以防止意外引用无法序列化的数据结构（如文件句柄或数据库连接）。</p>
<p>一种方法是使用实​​现语言的默认机制将数据结构序列化/反序列化为 JSON 等格式。在 Java 中可以使用 Jackson 库，Kotlin 有 <code>kotlinx.serialization</code> 库，Rust 则有 serde crate等。</p>
<p>另一种选择可能是定义一种与语言无关的序列化格式，如 Avro、Thrift 或 Protocol Buffers，然后编写代码在此格式和特定于语言实现之间进行转换。</p>
<p>自本书第一版发来以来，出现了一个名为 <a href="https://substrait.io/">“substrait”</a> 的新标准，其目标是为关系代数提供跨语言序列化。我对这个项目感到很兴奋，并预测它将成为表示查询计划的事实上的标准，并开辟许多集成的可能性。例如，可以使用成熟的基于 Java 的查询计划程序（例如 Apache Calcite），以 Substrait 格式序列化计划，然后在以较低级别语言（例如 C++ 或 Rust）实现的查询引擎中执行计划。欲了解更多信息，请访问 https://substrait.io/。</p>
<h2 id="逻辑表达式-logical-expressions"><a class="header" href="#逻辑表达式-logical-expressions">逻辑表达式 Logical Expressions</a></h2>
<p>表达式这一概念是查询计划的基本构建块之一，其可以在运行时对数据进行求值。</p>
<p>以下是查询引擎中通常支持的一些表达式示例。</p>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>示例</th></tr></thead><tbody>
<tr><td>Literal Value</td><td>"hello", 12.34</td></tr>
<tr><td>Column Reference</td><td>user_id, first_name, last_name</td></tr>
<tr><td>Math Expression</td><td>salary * state_tax</td></tr>
<tr><td>Comparison Expression</td><td>x &gt;= y</td></tr>
<tr><td>Boolean Expression</td><td>birthday = today() AND age &gt;= 21</td></tr>
<tr><td>Aggregate Expression</td><td>MIN(salary), MAX(salary), SUM(salary), AVG(salary), COUNT(*)</td></tr>
<tr><td>Scalar Function</td><td>CONCAT(first_name, " ", last_name)</td></tr>
<tr><td>Aliased Expression</td><td>salary * 0.02 AS pay_increase</td></tr>
</tbody></table>
</div>
<p>当然，所有这些表达式都可以组合形成深层嵌套的表达式树。表达式求值是递归编程的典型案例。</p>
<p>在规划查询时，我们需要了解有关表达式输出的一些基本元数据。具体来说，我们需要为表达式指定一个名称，以便其他表达式可以引用它，并且我们需要知道表达式求值时将生成的值的数据类型，以便我们可以验证查询计划是否有效。例如，如果我们有一个表达式 <code>a + b</code> ，那么只有当 <code>a</code> 和 <code>b</code> 都是数值类型时才有效。</p>
<p>还需注意，表达式的数据类型可能取决于输入数据。例如，列引用将具有它所引用的列的数据类型，但比较表达式始终返回布尔值。</p>
<pre><code class="language-kotlin">interface LogicalExpr {
  fun toField(input: LogicalPlan): Field
}
</code></pre>
<h3 id="列式表达式-column-expressions"><a class="header" href="#列式表达式-column-expressions">列式表达式 Column Expressions</a></h3>
<p><code>Column</code> 表达式仅代表对一个命名列的引用。该表达式的元数据是通过在输入中查找指定列并返回该列的元数据而派生的。请注意，此处的术语 <code>Column</code> 指的是由输入逻辑计划生成的列，并且可以表示数据源中的列，或者它可以表示针对其他输入求值的表达式的结果。</p>
<pre><code class="language-kotlin">class Column(val name: String): LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return input.schema().fields.find { it.name == name } ?:
      throw SQLException("No column named '$name'")
  }

  override fun toString(): String {
    return "#$name"
  }

}
</code></pre>
<h3 id="字面量表达式-literal-expressions"><a class="header" href="#字面量表达式-literal-expressions">字面量表达式 Literal Expressions</a></h3>
<p>我们需要能够将字面量表示为表达式的能力，以便我们可以编写像 <code>salary * 0.05</code> 这样的表达式。</p>
<p>这是一个用于字符串字面量的表达式示例。</p>
<pre><code class="language-kotlin">class LiteralString(val str: String): LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(str, ArrowTypes.StringType)
  }

  override fun toString(): String {
    return "'$str'"
  }

}
</code></pre>
<p>这是一个用于长整型字面值的表达式示例。</p>
<pre><code class="language-kotlin">class LiteralLong(val n: Long): LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
      return Field(n.toString(), ArrowTypes.Int64Type)
  }

  override fun toString(): String {
      return n.toString()
  }

}
</code></pre>
<h3 id="二元表达式-binary-expressions"><a class="header" href="#二元表达式-binary-expressions">二元表达式 Binary Expressions</a></h3>
<p>二元表达式简单来说就是只接受两个输入的表达式。我们将实现三类二元表达式，即比较表达式、布尔表达式和数学表达式。因为所有这些的字符串表示形式都是相同的，我们可以使用一个公共基类来提供<code>toString</code>方法。变量 “l” 和 “r” 分别指左输入和右输入。</p>
<pre><code class="language-kotlin">abstract class BinaryExpr(
    val name: String,
    val op: String,
    val l: LogicalExpr,
    val r: LogicalExpr) : LogicalExpr {

  override fun toString(): String {
    return "$l $op $r"
  }
}
</code></pre>
<p>比如 <code>=</code> 或 <code>&lt;</code> 这样的比较表达式会比较两个相同数据类型的值，并返回一个布尔值。我们还需要实现布尔运算符 <code>AND</code> 和 <code>OR</code> ，它们也接受两个参数并产生一个布尔结果，因此我们也可以为这些运算符使用一个公共基类。</p>
<pre><code class="language-kotlin">abstract class BooleanBinaryExpr(
    name: String,
    op: String,
    l: LogicalExpr,
    r: LogicalExpr) : BinaryExpr(name, op, l, r) {

  override fun toField(input: LogicalPlan): Field {
      return Field(name, ArrowTypes.BooleanType)
  }

}
</code></pre>
<p>该基类提供了一种简洁的方式来实现具体的比较表达式。</p>
<h3 id="比较表达式-comparison-expressions"><a class="header" href="#比较表达式-comparison-expressions">比较表达式 Comparison Expressions</a></h3>
<pre><code class="language-kotlin">/** Equality (`=`) comparison */
class Eq(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("eq", "=", l, r)

/** Inequality (`!=`) comparison */
class Neq(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("neq", "!=", l, r)

/** Greater than (`&gt;`) comparison */
class Gt(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("gt", "&gt;", l, r)

/** Greater than or equals (`&gt;=`) comparison */
class GtEq(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("gteq", "&gt;=", l, r)

/** Less than (`&lt;`) comparison */
class Lt(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("lt", "&lt;", l, r)

/** Less than or equals (`&lt;=`) comparison */
class LtEq(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("lteq", "&lt;=", l, r)
</code></pre>
<h3 id="布尔表达式-boolean-expressions"><a class="header" href="#布尔表达式-boolean-expressions">布尔表达式 Boolean Expressions</a></h3>
<p>该基类还提供了一种简洁的方式来实现具体的布尔逻辑表达式。</p>
<pre><code class="language-kotlin">/** Logical AND */
class And(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("and", "AND", l, r)

/** Logical OR */
class Or(l: LogicalExpr, r: LogicalExpr)
    : BooleanBinaryExpr("or", "OR", l, r)
</code></pre>
<h3 id="数学表达式-math-expressions"><a class="header" href="#数学表达式-math-expressions">数学表达式 Math Expressions</a></h3>
<p>数学表达式是二元表达式的另一种特殊形式。数学表达式通常对相同数据类型的值进行运算并产生相同数据类型的结果。</p>
<pre><code class="language-kotlin">abstract class MathExpr(
    name: String,
    op: String,
    l: LogicalExpr,
    r: LogicalExpr) : BinaryExpr(name, op, l, r) {

  override fun toField(input: LogicalPlan): Field {
      return Field("mult", l.toField(input).dataType)
  }

}

class Add(l: LogicalExpr, r: LogicalExpr) : MathExpr("add", "+", l, r)
class Subtract(l: LogicalExpr, r: LogicalExpr) : MathExpr("subtract", "-", l, r)
class Multiply(l: LogicalExpr, r: LogicalExpr) : MathExpr("mult", "*", l, r)
class Divide(l: LogicalExpr, r: LogicalExpr) : MathExpr("div", "/", l, r)
class Modulus(l: LogicalExpr, r: LogicalExpr) : MathExpr("mod", "%", l, r)
</code></pre>
<h3 id="聚合表达式-aggregate-expressions"><a class="header" href="#聚合表达式-aggregate-expressions">聚合表达式 Aggregate Expressions</a></h3>
<p>聚合表达式对输入表达式执行聚合函数，如 <code>MIN</code>、<code>MAX</code>、<code>COUNT</code>、<code>SUM</code> 或者 <code>AVG</code> 等。</p>
<pre><code class="language-kotlin">abstract class AggregateExpr(
    val name: String,
    val expr: LogicalExpr) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(name, expr.toField(input).dataType)
  }

  override fun toString(): String {
    return "$name($expr)"
  }
}
</code></pre>
<p>对于聚合数据类型与输入类型相同的聚合表达式，我们可以简单地扩展这个基类。</p>
<pre><code class="language-kotlin">class Sum(input: LogicalExpr) : AggregateExpr("SUM", input)
class Min(input: LogicalExpr) : AggregateExpr("MIN", input)
class Max(input: LogicalExpr) : AggregateExpr("MAX", input)
class Avg(input: LogicalExpr) : AggregateExpr("AVG", input)
</code></pre>
<p>对于数据类型不依赖于输入类型的聚合表达式，我们需要重写 <code>toField</code> 方法。例如，“COUNT” 聚合表达式无论计数值的数据类型为何，总是产生一个整数结果。</p>
<pre><code class="language-kotlin">class Count(input: LogicalExpr) : AggregateExpr("COUNT", input) {

  override fun toField(input: LogicalPlan): Field {
    return Field("COUNT", ArrowTypes.Int32Type)
  }

  override fun toString(): String {
    return "COUNT($expr)"
  }
}
</code></pre>
<h2 id="逻辑计划-logical-plans"><a class="header" href="#逻辑计划-logical-plans">逻辑计划 Logical Plans</a></h2>
<p>有了逻辑表达式，逻辑表达式就位后，我们现在可以为查询引擎支持的各种转换实现逻辑计划。</p>
<h3 id="扫描-scan"><a class="header" href="#扫描-scan">扫描 Scan</a></h3>
<p><code>扫描（Scan）</code> 逻辑计划表示根据可选 <code>映射（projection）</code>从一个 <code>数据源（DataSource）</code> 中获取数据。在我们查询引擎中 <code>扫描（Scan）</code> 逻辑计划是唯一没有其他逻辑计划作为输入的逻辑计划，它是查询树中的叶节点。</p>
<pre><code class="language-kotlin">class Scan(
    val path: String,
    val dataSource: DataSource,
    val projection: List&lt;String&gt;): LogicalPlan {

  val schema = deriveSchema()

  override fun schema(): Schema {
    return schema
  }

  private fun deriveSchema() : Schema {
    val schema = dataSource.schema()
    if (projection.isEmpty()) {
      return schema
    } else {
      return schema.select(projection)
    }
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf()
  }

  override fun toString(): String {
    return if (projection.isEmpty()) {
      "Scan: $path; projection=None"
    } else {
      "Scan: $path; projection=$projection"
    }
  }

}
</code></pre>
<h3 id="映射-projection"><a class="header" href="#映射-projection">映射 Projection</a></h3>
<p><code>映射（Projection）</code> 逻辑计划对其输入应用映射。一个映射是对输入数据进行求值的一系列表达式列表。有时候这是一个简单的字段列表, 比如 <code>SELECT a, b, c FROM foo</code>, 但也可能包括任何其他支持的表达式，一个更复杂例子可能是： <code>SELECT (CAST(a AS float) * 3.141592)) AS my_float FROM foo</code>。</p>
<pre><code class="language-kotlin">class Projection(
    val input: LogicalPlan,
    val expr: List&lt;LogicalExpr&gt;): LogicalPlan {

  override fun schema(): Schema {
    return Schema(expr.map { it.toField(input) })
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Projection: ${ expr.map {
        it.toString() }.joinToString(", ")
    }"
  }
}
</code></pre>
<h3 id="筛选也称为过滤器-selection-also-known-as-filter"><a class="header" href="#筛选也称为过滤器-selection-also-known-as-filter">筛选（也称为过滤器） Selection (also known as Filter)</a></h3>
<p><code>筛选（Selection）</code> 逻辑计划通过应用过滤器表达式来确定应在其输出中选择（包含）哪些行。这在 SQL 中用 <code>WHERE</code> 子句表示。一个简单例子可能是：<code>SELECT * FROM foo WHERE a &gt; 5</code>，过滤器表达式需要求值出一个布尔结果。</p>
<pre><code class="language-kotlin">class Selection(
    val input: LogicalPlan,
    val expr: Expr): LogicalPlan {

  override fun schema(): Schema {
    // selection does not change the schema of the input
    return input.schema()
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Filter: $expr"
  }
}
</code></pre>
<h3 id="聚合-aggregate"><a class="header" href="#聚合-aggregate">聚合 Aggregate</a></h3>
<p><code>聚合（Aggregate）</code> 逻辑计划远比 <code>映射（Projection）</code>、<code>筛选（Selection）</code> 或者 <code>扫描（Scan）</code> 复杂，并且能够计算出底层数据如 最小值、最大值、平均值 和 总和 等聚集信息。聚合通常按其他列（或表达式）进行分组。一个简单例子可能是：<code>SELECT job_title, AVG(salary) FROM employee GROUP BY job_title</code>。</p>
<pre><code class="language-kotlin">class Aggregate(
    val input: LogicalPlan,
    val groupExpr: List&lt;LogicalExpr&gt;,
    val aggregateExpr: List&lt;AggregateExpr&gt;) : LogicalPlan {

  override fun schema(): Schema {
    return Schema(groupExpr.map { it.toField(input) } +
         		  aggregateExpr.map { it.toField(input) })
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Aggregate: groupExpr=$groupExpr, aggregateExpr=$aggregateExpr"
  }
}
</code></pre>
<p>请注意，在此实现中，聚合计划的输出是通过分组列和聚合表达式来组织的。通常需要将聚合逻辑计划包装在映射中，以便按照原始查询中的请求顺序返回列。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建逻辑计划"><a class="header" href="#构建逻辑计划">构建逻辑计划</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>dataframe</code> 模块中找到。</em></p>
<h2 id="用困难的方式构建逻辑计划"><a class="header" href="#用困难的方式构建逻辑计划">用困难的方式构建逻辑计划</a></h2>
<p>既然我们已经为逻辑计划的子集定义了类，我们就可以以编程方式组合它们。</p>
<p>这里有一些具体的代码，用于构建针对包含列 <code>id, first_name, last_name, state, job_title, salary</code> 的 CSV 文件的查询 <code>SELECT * FROM employee WHERE state = 'CO'</code> 的计划。</p>
<pre><code class="language-kotlin">// create a plan to represent the data source
val csv = CsvDataSource("employee.csv")

// create a plan to represent the scan of the data source (FROM)
val scan = Scan("employee", csv, listOf())

// create a plan to represent the selection (WHERE)
val filterExpr = Eq(Column("state"), LiteralString("CO"))
val selection = Selection(scan, filterExpr)

// create a plan to represent the projection (SELECT)
val projectionList = listOf(Column("id"),
                            Column("first_name"),
                            Column("last_name"),
                            Column("state"),
                            Column("salary"))
val plan = Projection(selection, projectionList)

// print the plan
println(format(plan))
</code></pre>
<p>此操作将打印以下计划：</p>
<pre><code>Projection: #id, #first_name, #last_name, #state, #salary
    Filter: #state = 'CO'
        Scan: employee; projection=None
</code></pre>
<p>同样的代码也可以像这样写得更加简洁：</p>
<pre><code class="language-kotlin">val plan = Projection(
  Selection(
    Scan("employee", CsvDataSource("employee.csv"), listOf()),
    Eq(Column(3), LiteralString("CO"))
  ),
  listOf(Column("id"),
         Column("first_name"),
         Column("last_name"),
         Column("state"),
         Column("salary"))
)
println(format(plan))
</code></pre>
<p>虽然这样更加简洁，但也更难以解释，所以最好能有一种更优雅的方式来创建逻辑计划。这就是 <code>DataFrame</code> 接口能够帮助到我们的地方。</p>
<h2 id="使用-dataframe-构建逻辑计划"><a class="header" href="#使用-dataframe-构建逻辑计划">使用 DataFrame 构建逻辑计划</a></h2>
<p>实现一个 DataFrame 风格的 API 允许我们以一种更加用户友好的方式构建逻辑查询计划。<code>DataFrame</code> 只是逻辑查询计划的抽象，并且具有执行转换和操作的方法。它类似于 <code>fluent-style</code> 的构建器 API。</p>
<p>这是一个 <code>DataFrame</code> 接口的最小化示例，它允许我们将 映射（projection）和 过滤器（selection）应用于现有的 <code>DataFrame</code>。</p>
<pre><code class="language-kotlin">interface DataFrame {

  /** Apply a projection */
  fun project(expr: List&lt;LogicalExpr&gt;): DataFrame

  /** Apply a filter */
  fun filter(expr: LogicalExpr): DataFrame

  /** Aggregate */
  fun aggregate(groupBy: List&lt;LogicalExpr&gt;,
                aggregateExpr: List&lt;AggregateExpr&gt;): DataFrame

  /** Returns the schema of the data that will be produced by this DataFrame. */
  fun schema(): Schema

  /** Get the logical plan */
  fun logicalPlan() : LogicalPlan

}
</code></pre>
<p>下面是这个接口的实现。</p>
<pre><code class="language-kotlin">class DataFrameImpl(private val plan: LogicalPlan) : DataFrame {

  override fun project(expr: List&lt;LogicalExpr&gt;): DataFrame {
    return DataFrameImpl(Projection(plan, expr))
  }

  override fun filter(expr: LogicalExpr): DataFrame {
    return DataFrameImpl(Selection(plan, expr))
  }

  override fun aggregate(groupBy: List&lt;LogicalExpr&gt;,
                         aggregateExpr: List&lt;AggregateExpr&gt;): DataFrame {
    return DataFrameImpl(Aggregate(plan, groupBy, aggregateExpr))
  }

  override fun schema(): Schema {
    return plan.schema()
  }

  override fun logicalPlan(): LogicalPlan {
    return plan
  }

}
</code></pre>
<p>在应用 映射（projection）或 过滤器（selection）之前，我们需要一种方法来创建表示底层数据源的初始 DataFrame。这通常是通过执行上下文获得的。</p>
<p>这是执行上下文的一个简单开始，我们稍后将对其进行增强。</p>
<pre><code class="language-kotlin">class ExecutionContext {

  fun csv(filename: String): DataFrame {
    return DataFrameImpl(Scan(filename, CsvDataSource(filename), listOf()))
  }

  fun parquet(filename: String): DataFrame {
    return DataFrameImpl(Scan(filename, ParquetDataSource(filename), listOf()))
  }
}
</code></pre>
<p>有了这些基础工作，我们现在可以使用上下文和 DataFrame API 创建逻辑查询计划。</p>
<pre><code class="language-kotlin">val ctx = ExecutionContext()

val plan = ctx.csv("employee.csv")
              .filter(Eq(Column("state"), LiteralString("CO")))
              .select(listOf(Column("id"),
                             Column("first_name"),
                             Column("last_name"),
                             Column("state"),
                             Column("salary")))
</code></pre>
<p>尽管如此清晰直观，但我们还能进一步添加一些方便的方法使其变得更易理解。这是 Kotlin 特有的，但其他语言也有类似的概念。</p>
<p>我们可以创建一些方便的方法来创建支持的表达式对象。</p>
<pre><code class="language-kotlin">fun col(name: String) = Column(name)
fun lit(value: String) = LiteralString(value)
fun lit(value: Long) = LiteralLong(value)
fun lit(value: Double) = LiteralDouble(value)
</code></pre>
<p>我们还可以在 <code>LogicalExpr</code> 接口上定义中缀运算符来构建二元表达式。</p>
<pre><code class="language-kotlin">infix fun LogicalExpr.eq(rhs: LogicalExpr): LogicalExpr { return Eq(this, rhs) }
infix fun LogicalExpr.neq(rhs: LogicalExpr): LogicalExpr { return Neq(this, rhs) }
infix fun LogicalExpr.gt(rhs: LogicalExpr): LogicalExpr { return Gt(this, rhs) }
infix fun LogicalExpr.gteq(rhs: LogicalExpr): LogicalExpr { return GtEq(this, rhs) }
infix fun LogicalExpr.lt(rhs: LogicalExpr): LogicalExpr { return Lt(this, rhs) }
infix fun LogicalExpr.lteq(rhs: LogicalExpr): LogicalExpr { return LtEq(this, rhs) }
</code></pre>
<p>有了这些方便的方法，我们现在可以编写富有表达力的代码来构建我们的逻辑查询计划了。</p>
<pre><code class="language-kotlin">val df = ctx.csv(employeeCsv)
   .filter(col("state") eq lit("CO"))
   .select(listOf(
       col("id"),
       col("first_name"),
       col("last_name"),
       col("salary"),
       (col("salary") mult lit(0.1)) alias "bonus"))
   .filter(col("bonus") gt lit(1000))
</code></pre>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="物理计划和表达式"><a class="header" href="#物理计划和表达式">物理计划和表达式</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>physical-plan</code> 模块中找到。</em></p>
<p>第五章定义的逻辑计划指明了要做什么，但没有说明如何去做，将逻辑计划和物理计划分开是一个好习惯，尽管可以将它们结合起来以降低复杂性。</p>
<p>将逻辑计划和物理计划分开的原因之一是，有时可以有多种方法来执行特定操作，这意味着逻辑计划和物理计划之间存在一对多的关系。</p>
<p>例如，单进程与分布式执行、CPU 与 GPU 执行可能有不同的物理计划。</p>
<p>此外，诸如 <code>聚合（Aggregate）</code> 和 <code>联表（Join）</code> 之类的操作可以通过各种算法实现，并且具有不同的性能权衡。当聚合已经按 分组字段（grouping keys）排序的数据时，使用 Group Aggregate（也称为Sort Aggregate）非常有效，它一次只需要保存一组 分组字段（grouping keys）的状态，并且可以在一组数据处理完毕立即给出结果。如果数据未排序，则通常使用哈希聚合，哈希聚合通过对键进行分组来维护一个 HashMap 累加器。</p>
<p>联表则有更广泛的算法选择，包括 嵌套循环连接（Nested Loop Join）、排序合并连接（Sort-Merge Join）和 哈希连接（Hash Join）。</p>
<p>物理计划返回 记录批次（record batches）的迭代器。</p>
<pre><code class="language-kotlin">interface PhysicalPlan {
  fun schema(): Schema
  fun execute(): Sequence&lt;RecordBatch&gt;
  fun children(): List&lt;PhysicalPlan&gt;
}
</code></pre>
<h2 id="物理表达式-physical-expressions"><a class="header" href="#物理表达式-physical-expressions">物理表达式 Physical Expressions</a></h2>
<p>我们已经定义了逻辑计划中引用的逻辑表达式，但现在需要实现包含代码的物理表达式类，以在运行时计算表达式。</p>
<p>每个逻辑表达式可以有多个物理表达式实现。例如，对于将两个数字相加的逻辑表达式 <code>AddExpr</code>，我们可以有一种使用 CPU 的实现和一种使用 GPU 的实现。查询规划器可以根据运行代码的服务器的硬件能力来选择使用哪一个。</p>
<p>物理表达式是针对 记录批次（record batches）进行计算的，其结果是列。</p>
<p>以下是我们将用来表示物理表达式的接口。</p>
<pre><code class="language-kotlin">interface Expression {
  fun evaluate(input: RecordBatch): ColumnVector
}
</code></pre>
<h3 id="列表达式-column-expressions"><a class="header" href="#列表达式-column-expressions">列表达式 Column Expressions</a></h3>
<p><code>Column</code> 表达式简单地求值为对正在处理的 <code>RecordBatch</code> 中的 <code>ColumnVector</code> 的引用。<code>Column</code> 的逻辑表达式通过名称引用输入，这对编写查询来说是用户友好的，但对于物理表达式，我们希望避免每次评估表达式时都进行名称查找的成本，因此它改为通过索引引用列。</p>
<pre><code class="language-kotlin">class ColumnExpression(val i: Int) : Expression {

  override fun evaluate(input: RecordBatch): ColumnVector {
    return input.field(i)
  }

  override fun toString(): String {
    return "#$i"
  }
}
</code></pre>
<h3 id="字面量表达式-literal-expressions-1"><a class="header" href="#字面量表达式-literal-expressions-1">字面量表达式 Literal Expressions</a></h3>
<p>字面量表达式的物理实现就是一个包装在类中的字面值，该类实现了相应特性并为列中每个索引提供相同的值。</p>
<pre><code class="language-kotlin">class LiteralValueVector(
    val arrowType: ArrowType,
    val value: Any?,
    val size: Int) : ColumnVector {

  override fun getType(): ArrowType {
    return arrowType
  }

  override fun getValue(i: Int): Any? {
    if (i&lt;0 || i&gt;=size) {
      throw IndexOutOfBoundsException()
    }
    return value
  }

  override fun size(): Int {
    return size
  }

}
</code></pre>
<p>有了这个类，我们就可以为每种数据类型的字面量表达式创建物理表达式。</p>
<pre><code class="language-kotlin">class LiteralLongExpression(val value: Long) : Expression {
  override fun evaluate(input: RecordBatch): ColumnVector {
    return LiteralValueVector(ArrowTypes.Int64Type,
                              value,
                              input.rowCount())
  }
}

class LiteralDoubleExpression(val value: Double) : Expression {
  override fun evaluate(input: RecordBatch): ColumnVector {
    return LiteralValueVector(ArrowTypes.DoubleType,
                              value,
                              input.rowCount())
  }
}

class LiteralStringExpression(val value: String) : Expression {
  override fun evaluate(input: RecordBatch): ColumnVector {
    return LiteralValueVector(ArrowTypes.StringType,
                              value.toByteArray(),
                              input.rowCount())
  }
}
</code></pre>
<h3 id="二元表达式-binary-expressions-1"><a class="header" href="#二元表达式-binary-expressions-1">二元表达式 Binary Expressions</a></h3>
<p>对于二元表达式，我们需要计算左右输入表达式，然后根据这些输入值计算特定的二元运算符，因此我们可以提供一个基类来简化每个运算符的实现。</p>
<pre><code class="language-kotlin">abstract class BinaryExpression(val l: Expression, val r: Expression) : Expression {
  override fun evaluate(input: RecordBatch): ColumnVector {
    val ll = l.evaluate(input)
    val rr = r.evaluate(input)
    assert(ll.size() == rr.size())
    if (ll.getType() != rr.getType()) {
      throw IllegalStateException(
          "Binary expression operands do not have the same type: " +
          "${ll.getType()} != ${rr.getType()}")
    }
    return evaluate(ll, rr)
  }

  abstract fun evaluate(l: ColumnVector, r: ColumnVector) : ColumnVector
}
</code></pre>
<h3 id="比较表达式-comparison-expressions-1"><a class="header" href="#比较表达式-comparison-expressions-1">比较表达式 Comparison Expressions</a></h3>
<p>比较表达式只是简单地比较两个输入列中的所有值并生成包含结果的新列（位向量 bit vector）。</p>
<p>以下是相等运算符的一个例子。</p>
<pre><code class="language-kotlin">class EqExpression(l: Expression,
                   r: Expression): BooleanExpression(l,r) {

  override fun evaluate(l: Any?, r: Any?, arrowType: ArrowType) : Boolean {
    return when (arrowType) {
      ArrowTypes.Int8Type -&gt; (l as Byte) == (r as Byte)
      ArrowTypes.Int16Type -&gt; (l as Short) == (r as Short)
      ArrowTypes.Int32Type -&gt; (l as Int) == (r as Int)
      ArrowTypes.Int64Type -&gt; (l as Long) == (r as Long)
      ArrowTypes.FloatType -&gt; (l as Float) == (r as Float)
      ArrowTypes.DoubleType -&gt; (l as Double) == (r as Double)
      ArrowTypes.StringType -&gt; toString(l) == toString(r)
      else -&gt; throw IllegalStateException(
          "Unsupported data type in comparison expression: $arrowType")
    }
  }
}
</code></pre>
<h3 id="数学表达式-math-expressions-1"><a class="header" href="#数学表达式-math-expressions-1">数学表达式 Math Expressions</a></h3>
<p>数学表达式的实现与比较表达式的代码非常相似。一个基类可以用于所有数学表达式。</p>
<pre><code class="language-kotlin">abstract class MathExpression(l: Expression,
                              r: Expression): BinaryExpression(l,r) {

  override fun evaluate(l: ColumnVector, r: ColumnVector): ColumnVector {
    val fieldVector = FieldVectorFactory.create(l.getType(), l.size())
    val builder = ArrowVectorBuilder(fieldVector)
    (0 until l.size()).forEach {
      val value = evaluate(l.getValue(it), r.getValue(it), l.getType())
      builder.set(it, value)
    }
    builder.setValueCount(l.size())
    return builder.build()
  }

  abstract fun evaluate(l: Any?, r: Any?, arrowType: ArrowType) : Any?
}
</code></pre>
<p>下面是扩展此基类的特定数学表达式的一个例子。</p>
<pre><code class="language-kotlin">class AddExpression(l: Expression,
                    r: Expression): MathExpression(l,r) {

  override fun evaluate(l: Any?, r: Any?, arrowType: ArrowType) : Any? {
      return when (arrowType) {
        ArrowTypes.Int8Type -&gt; (l as Byte) + (r as Byte)
        ArrowTypes.Int16Type -&gt; (l as Short) + (r as Short)
        ArrowTypes.Int32Type -&gt; (l as Int) + (r as Int)
        ArrowTypes.Int64Type -&gt; (l as Long) + (r as Long)
        ArrowTypes.FloatType -&gt; (l as Float) + (r as Float)
        ArrowTypes.DoubleType -&gt; (l as Double) + (r as Double)
        else -&gt; throw IllegalStateException(
            "Unsupported data type in math expression: $arrowType")
      }
  }

  override fun toString(): String {
    return "$l+$r"
  }
}
</code></pre>
<h3 id="聚合表达式-aggregate-expressions-1"><a class="header" href="#聚合表达式-aggregate-expressions-1">聚合表达式 Aggregate Expressions</a></h3>
<p>到目前为止，我们所研究的表达式都是从每个批次中的一列或多列输入生成一个输出列。聚合表达式会更复杂，因为它们聚合多批数据中的值，然后生成一个最终值，因此我们需要引入累加器的概念，每个聚合表达式的物理表示需要知道如何为查询引擎生成适当的累加器来传递输入数据。</p>
<p>以下是表示聚合表达式和累加器的主要接口。</p>
<pre><code class="language-kotlin">interface AggregateExpression {
  fun inputExpression(): Expression
  fun createAccumulator(): Accumulator
}

interface Accumulator {
  fun accumulate(value: Any?)
  fun finalValue(): Any?
}
</code></pre>
<p>聚合表达式 <code>Max</code> 的实现将会生成一个特定的 最大值累加器（MaxAccumulator）。</p>
<pre><code class="language-kotlin">class MaxExpression(private val expr: Expression) : AggregateExpression {

  override fun inputExpression(): Expression {
    return expr
  }

  override fun createAccumulator(): Accumulator {
    return MaxAccumulator()
  }

  override fun toString(): String {
    return "MAX($expr)"
  }
}
</code></pre>
<p>以下是 MaxAccumulator 的实现示例。</p>
<pre><code class="language-kotlin">class MaxAccumulator : Accumulator {

  var value: Any? = null

  override fun accumulate(value: Any?) {
    if (value != null) {
      if (this.value == null) {
        this.value = value
      } else {
        val isMax = when (value) {
          is Byte -&gt; value &gt; this.value as Byte
          is Short -&gt; value &gt; this.value as Short
          is Int -&gt; value &gt; this.value as Int
          is Long -&gt; value &gt; this.value as Long
          is Float -&gt; value &gt; this.value as Float
          is Double -&gt; value &gt; this.value as Double
          is String -&gt; value &gt; this.value as String
          else -&gt; throw UnsupportedOperationException(
            "MAX is not implemented for data type: ${value.javaClass.name}")
        }

        if (isMax) {
          this.value = value
        }
      }
    }
  }

  override fun finalValue(): Any? {
    return value
  }
}
</code></pre>
<h2 id="物理计划-physical-plans"><a class="header" href="#物理计划-physical-plans">物理计划 Physical Plans</a></h2>
<p>有了物理表达式之后，我们现在可以为查询引擎将支持各种转换实现物理计划了。</p>
<h3 id="扫描-scan-1"><a class="header" href="#扫描-scan-1">扫描 Scan</a></h3>
<p><code>扫描（Scan）</code> 执行计划只是委派给数据源，传入一个 映射（Projection）来限制加载到内存中的列。不执行附加逻辑。</p>
<pre><code class="language-kotlin">class ScanExec(val ds: DataSource, val projection: List&lt;String&gt;) : PhysicalPlan {

  override fun schema(): Schema {
    return ds.schema().select(projection)
  }

  override fun children(): List&lt;PhysicalPlan&gt; {
    // Scan is a leaf node and has no child plans
    return listOf()
  }

  override fun execute(): Sequence&lt;RecordBatch&gt; {
    return ds.scan(projection);
  }

  override fun toString(): String {
    return "ScanExec: schema=${schema()}, projection=$projection"
  }
}
</code></pre>
<h3 id="映射-projection-1"><a class="header" href="#映射-projection-1">映射 Projection</a></h3>
<p>映射（Projection）执行计划只是根据输入列评估映射（Projection）表达式，然后生成包含派生列的记录批次（record batch）。请注意，对于按名称引用现有列的映射（Projection）表达式的情况，派生列只是对输入列的指针或引用，因此不会复制底层数据。</p>
<pre><code class="language-kotlin">class ProjectionExec(
    val input: PhysicalPlan,
    val schema: Schema,
    val expr: List&lt;Expression&gt;) : PhysicalPlan {

  override fun schema(): Schema {
    return schema
  }

  override fun children(): List&lt;PhysicalPlan&gt; {
    return listOf(input)
  }

  override fun execute(): Sequence&lt;RecordBatch&gt; {
    return input.execute().map { batch -&gt;
      val columns = expr.map { it.evaluate(batch) }
        RecordBatch(schema, columns)
      }
  }

  override fun toString(): String {
    return "ProjectionExec: $expr"
  }
}
</code></pre>
<h3 id="筛选也称为过滤器-selection-also-known-as-filter-1"><a class="header" href="#筛选也称为过滤器-selection-also-known-as-filter-1">筛选（也称为过滤器） Selection (also known as Filter)</a></h3>
<p>筛选执行计划是第一个重要的计划，因为它具有条件逻辑来确定输入记录批次中的哪些行应包含在输出批次中。</p>
<p>对于每个输入批次，筛选表达式被执行以返回一个位向量（bit vector），其中包含表示表达式布尔结果的位，每行一位。然后使用该位向量过滤输入列以生成新的输出列。这是一种简单实现，可以针对位向量包含全 1 或全 0 的情况进行优化，以避免将数据复制到新向量的开销。</p>
<pre><code class="language-kotlin">class SelectionExec(
    val input: PhysicalPlan,
    val expr: Expression) : PhysicalPlan {

  override fun schema(): Schema {
    return input.schema()
  }

  override fun children(): List&lt;PhysicalPlan&gt; {
    return listOf(input)
  }

  override fun execute(): Sequence&lt;RecordBatch&gt; {
    val input = input.execute()
    return input.map { batch -&gt;
      val result = (expr.evaluate(batch) as ArrowFieldVector).field as BitVector
      val schema = batch.schema
      val columnCount = batch.schema.fields.size
      val filteredFields = (0 until columnCount).map {
          filter(batch.field(it), result)
      }
      val fields = filteredFields.map { ArrowFieldVector(it) }
      RecordBatch(schema, fields)
    }

  private fun filter(v: ColumnVector, selection: BitVector) : FieldVector {
    val filteredVector = VarCharVector("v",
                                       RootAllocator(Long.MAX_VALUE))
    filteredVector.allocateNew()

    val builder = ArrowVectorBuilder(filteredVector)

    var count = 0
    (0 until selection.valueCount).forEach {
      if (selection.get(it) == 1) {
        builder.set(count, v.getValue(it))
        count++
      }
    }
    filteredVector.valueCount = count
    return filteredVector
  }
}
</code></pre>
<h3 id="哈希聚合-hash-aggregate"><a class="header" href="#哈希聚合-hash-aggregate">哈希聚合 Hash Aggregate</a></h3>
<p>哈希聚合计划（HashAggregate）比以前的计划更复杂，因为它必须处理所有传入批次并维护累加器的 HashMap 并更新正在处理的每一行的累加器。最后，利用累加器结果创建一个包含聚合查询结果的记录批次（record batch）。</p>
<pre><code class="language-kotlin">class HashAggregateExec(
    val input: PhysicalPlan,
    val groupExpr: List&lt;PhysicalExpr&gt;,
    val aggregateExpr: List&lt;PhysicalAggregateExpr&gt;,
    val schema: Schema) : PhysicalPlan {

  override fun schema(): Schema {
    return schema
  }

  override fun children(): List&lt;PhysicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "HashAggregateExec: groupExpr=$groupExpr, aggrExpr=$aggregateExpr"
  }

  override fun execute(): Sequence&lt;RecordBatch&gt; {
    val map = HashMap&lt;List&lt;Any?&gt;, List&lt;Accumulator&gt;&gt;()

    // for each batch from the input executor
    input.execute().iterator().forEach { batch -&gt;

    // evaluate the grouping expressions
    val groupKeys = groupExpr.map { it.evaluate(batch) }

    // evaluate the expressions that are inputs to the aggregate functions
    val aggrInputValues = aggregateExpr.map {
        it.inputExpression().evaluate(batch)
    }

    // for each row in the batch
    (0 until batch.rowCount()).forEach { rowIndex -&gt;
      // create the key for the hash map
      val rowKey = groupKeys.map {
      val value = it.getValue(rowIndex)
      when (value) {
        is ByteArray -&gt; String(value)
        else -&gt; value
      }
    }

    // get or create accumulators for this grouping key
    val accumulators = map.getOrPut(rowKey) {
        aggregateExpr.map { it.createAccumulator() }
    }

    // perform accumulation
    accumulators.withIndex().forEach { accum -&gt;
      val value = aggrInputValues[accum.index].getValue(rowIndex)
      accum.value.accumulate(value)
    }

    // create result batch containing final aggregate values
    val allocator = RootAllocator(Long.MAX_VALUE)
    val root = VectorSchemaRoot.create(schema.toArrow(), allocator)
    root.allocateNew()
    root.rowCount = map.size

    val builders = root.fieldVectors.map { ArrowVectorBuilder(it) }

    map.entries.withIndex().forEach { entry -&gt;
      val rowIndex = entry.index
      val groupingKey = entry.value.key
      val accumulators = entry.value.value
      groupExpr.indices.forEach {
        builders[it].set(rowIndex, groupingKey[it])
      }
      aggregateExpr.indices.forEach {
        builders[groupExpr.size+it].set(rowIndex, accumulators[it].finalValue())
      }
    }

    val outputBatch = RecordBatch(schema, root.fieldVectors.map {
       ArrowFieldVector(it)
    })

    return listOf(outputBatch).asSequence()
  }

}
</code></pre>
<h3 id="联表-join"><a class="header" href="#联表-join">联表 Join</a></h3>
<p>顾名思义，Join 运算符连接两个关系中的行。有许多不同类型的具有不同的语义 Join：</p>
<ul>
<li><code>[INNER] JOIN</code>: 这是最常用的联表类型，创建一个包含来自左右输入的行的新关系行。当连接表达式仅包含左右输入的列之间的相等比较时，该连接称为“等连接”。等连接的一个例子是 <code>SELECT * FROM customer JOIN orders ON customer.id = order.customer_id</code>。</li>
<li><code>LEFT [OUTER] JOIN</code>: 左外连接生成包含左输入中所有值的行，并包含匹配条件的右输入中的行。如果右侧不匹配，则为右侧列生成空值。</li>
<li><code>RIGHT [OUTER] JOIN</code>: 这与左连接相反。返回右输入的所有行，并包含匹配条件的左输入中的行。如果左侧不匹配，则为左侧列生成空值。</li>
<li><code>SEMI JOIN</code>: 半连接类似于左连接，但它只返回左输入中与右输入匹配的行，不会从右输入返回任何数据。并非所有 SQL 实现都显式支持半连接，它们通常被编写为子查询。半连接的一个例子是 <code>SELECT id FROM foo WHERE EXISTS (SELECT * FROM bar WHERE foo.id = bar.id)</code>。</li>
<li><code>ANTI JOIN</code>: 反连接与半连接相反，仅返回左输入中与右输入不匹配的行。反连接的一个例子是 <code>SELECT id FROM foo WHERE NOT EXISTS (SELECT * FROM bar WHERE foo.id = bar.id)</code>。</li>
<li><code>CROSS JOIN</code>: 交叉连接返回左输入中的行与右输入中的行的所有可能组合。如果左侧输入包含 100 行，右侧输入包含 200 行，则将返回 20,000 行。这称为笛卡尔积。</li>
</ul>
<p>KQuery 尚未实现 Join 运算符。</p>
<h3 id="子查询-subqueries"><a class="header" href="#子查询-subqueries">子查询 Subqueries</a></h3>
<p>子查询是查询中的查询。它们可以是相关的，也可以是不相关的（涉及或不涉及其他关系的联接）。当子查询返回单一值时，它被称为标量子查询。</p>
<h4 id="标量子查询-scalar-subqueries"><a class="header" href="#标量子查询-scalar-subqueries">标量子查询 Scalar subqueries</a></h4>
<p>标量子查询返回单个值，并且可以在许多可以使用字面量的 SQL 表达式中使用。</p>
<p><em>下面是相关性标量子查询的一个例子：</em></p>
<p><code>SELECT id, name, (SELECT count(*) FROM orders WHERE customer_id = customers.id) AS num_orders FROM customers</code></p>
<p><em>下面是无相关性标量子查询的一个例子：</em></p>
<p><code>SELECT * FROM orders WHERE total &gt; (SELECT avg(total) FROM sales WHERE customer_state = 'CA')</code></p>
<p>相关性子查询在执行之前被转换为连接（这将在第 9 章中解释）。</p>
<p>无相关性的查询可以单独执行，并且结果值可以替换到上级查询中。</p>
<h4 id="exists-和-in-子查询"><a class="header" href="#exists-和-in-子查询">EXISTS 和 IN 子查询</a></h4>
<p><code>EXISTS</code> 和 <code>IN</code> 表达式（及其否定形式，<code>NOT EXISTS</code> 和 <code>NOT IN</code>）可以用来创建半连接和反连接。</p>
<p>下面是一个半连接的示例，它选择左侧关系（<code>foo</code>）中所有与子查询返回的行匹配的行。</p>
<p><code>SELECT id FROM foo WHERE EXISTS (SELECT * FROM bar WHERE foo.id = bar.id)</code></p>
<p>相关性子查询通常在逻辑计划优化期间转换为 联表（这在第 9 章中进行了解释）</p>
<p>KQuery 尚未实现子查询。</p>
<h2 id="创建物理计划"><a class="header" href="#创建物理计划">创建物理计划</a></h2>
<p>有了物理计划，下一步是构建一个查询规划器，从逻辑计划创建物理计划，我们将在下一章中讲解。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询规划器"><a class="header" href="#查询规划器">查询规划器</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>query-planner</code> 模块中找到。</em></p>
<p>我们已经定义了逻辑和物理查询计划，现在我们需要一个可以将逻辑计划转换为物理计划的查询计划器。</p>
<p>查询规划器可以基于配置选项或基于目标平台的硬件能力来选择不同的物理计划。例如，查询可以在 CPU 或 GPU 上、单个节点上或者分布在集群中执行。</p>
<h2 id="转换逻辑表达式"><a class="header" href="#转换逻辑表达式">转换逻辑表达式</a></h2>
<p>第一步是定义一种方法，以递归方式将逻辑表达式转换为物理表达式。以下代码示例演示了基于 switch 语句的实现，并展示了如何把具有两个输入表达式的二元表达式使用递归的方法来转换这些输入。这种方法遍历整个逻辑表达式树并创建相应的物理表达式树。</p>
<pre><code class="language-kotlin">fun createPhysicalExpr(expr: LogicalExpr,
                       input: LogicalPlan): PhysicalExpr = when (expr) {
  is ColumnIndex -&gt; ColumnExpression(expr.i)
  is LiteralString -&gt; LiteralStringExpression(expr.str)
  is BinaryExpr -&gt; {
    val l = createPhysicalExpr(expr.l, input)
    val r = createPhysicalExpr(expr.r, input)
    ...
  }
  ...
}
</code></pre>
<p>以下部分将解释每种类型表达式的实现。</p>
<h3 id="列表达式-column-expressions-1"><a class="header" href="#列表达式-column-expressions-1">列表达式 Column Expressions</a></h3>
<p>逻辑列表达式按名称引用列，但物理表达式使用列索引来提高性能，因此查询规划器需要执行从列名到列索引的转换，并在列名无效时抛出异常。</p>
<p>这个简化的示例查找第一个匹配的列名称，并没有检查是否有多个匹配的列，这应该是一个错误条件。</p>
<pre><code class="language-kotlin">is Column -&gt; {
  val i = input.schema().fields.indexOfFirst { it.name == expr.name }
  if (i == -1) {
    throw SQLException("No column named '${expr.name}'")
  }
  ColumnExpression(i)
</code></pre>
<h3 id="字面量表达式-literal-expressions-2"><a class="header" href="#字面量表达式-literal-expressions-2">字面量表达式 Literal Expressions</a></h3>
<p>字面量的物理表达式很简单，从逻辑表达式到物理表达式的映射很简单，因为我们需要复制字面值。</p>
<pre><code class="language-kotlin">is LiteralLong -&gt; LiteralLongExpression(expr.n)
is LiteralDouble -&gt; LiteralDoubleExpression(expr.n)
is LiteralString -&gt; LiteralStringExpression(expr.str)
</code></pre>
<h3 id="二元表达式-binary-expressions-2"><a class="header" href="#二元表达式-binary-expressions-2">二元表达式 Binary Expressions</a></h3>
<p>要为二元表达式创建物理表达式，我们首先需要为左右输入创建物理表达式，然后需要创建特定的物理表达式。</p>
<pre><code class="language-kotlin">is BinaryExpr -&gt; {
  val l = createPhysicalExpr(expr.l, input)
  val r = createPhysicalExpr(expr.r, input)
  when (expr) {
    // comparision
    is Eq -&gt; EqExpression(l, r)
    is Neq -&gt; NeqExpression(l, r)
    is Gt -&gt; GtExpression(l, r)
    is GtEq -&gt; GtEqExpression(l, r)
    is Lt -&gt; LtExpression(l, r)
    is LtEq -&gt; LtEqExpression(l, r)

    // boolean
    is And -&gt; AndExpression(l, r)
    is Or -&gt; OrExpression(l, r)

    // math
    is Add -&gt; AddExpression(l, r)
    is Subtract -&gt; SubtractExpression(l, r)
    is Multiply -&gt; MultiplyExpression(l, r)
    is Divide -&gt; DivideExpression(l, r)

    else -&gt; throw IllegalStateException(
        "Unsupported binary expression: $expr")
    }
}
</code></pre>
<h2 id="转换逻辑计划"><a class="header" href="#转换逻辑计划">转换逻辑计划</a></h2>
<p>我们需要实现一个递归函数来遍历逻辑计划树并将其转换为物理计划，使用前面描述的转换表达式的相同模式。</p>
<pre><code class="language-kotlin">fun createPhysicalPlan(plan: LogicalPlan) : PhysicalPlan {
  return when (plan) {
    is Scan -&gt; ...
    is Selection -&gt; ...
    ...
}
</code></pre>
<h3 id="扫描-scan-2"><a class="header" href="#扫描-scan-2">扫描 Scan</a></h3>
<p>转换扫描计划只需复制数据源引用和逻辑计划的映射。</p>
<pre><code class="language-kotlin">is Scan -&gt; ScanExec(plan.dataSource, plan.projection)
</code></pre>
<h3 id="映射-projection-2"><a class="header" href="#映射-projection-2">映射 Projection</a></h3>
<p>转换映射有两个步骤。首先，我们需要为映射的输入创建一个物理计划，然后我们需要将映射的逻辑表达式转换为物理表达式。</p>
<pre><code class="language-kotlin">is Projection -&gt; {
  val input = createPhysicalPlan(plan.input)
  val projectionExpr = plan.expr.map { createPhysicalExpr(it, plan.input) }
  val projectionSchema = Schema(plan.expr.map { it.toField(plan.input) })
  ProjectionExec(input, projectionSchema, projectionExpr)
}
</code></pre>
<h3 id="筛选也称为过滤器-selection-also-known-as-filter-2"><a class="header" href="#筛选也称为过滤器-selection-also-known-as-filter-2">筛选（也称为过滤器） Selection (also known as Filter)</a></h3>
<p><code>Selection</code> 的查询规划步骤与 <code>Projection</code> 非常相似。</p>
<pre><code class="language-kotlin">is Selection -&gt; {
  val input = createPhysicalPlan(plan.input)
  val filterExpr = createPhysicalExpr(plan.expr, plan.input)
  SelectionExec(input, filterExpr)
}
</code></pre>
<h3 id="聚合-aggregate-1"><a class="header" href="#聚合-aggregate-1">聚合 Aggregate</a></h3>
<p>聚合查询的查询规划步骤涉及计算定义可选 分组键（grouping keys）的表达式和计算作为聚合函数的输入的表达式，然后创建物理聚合表达式。</p>
<pre><code class="language-kotlin">is Aggregate -&gt; {
  val input = createPhysicalPlan(plan.input)
  val groupExpr = plan.groupExpr.map { createPhysicalExpr(it, plan.input) }
  val aggregateExpr = plan.aggregateExpr.map {
    when (it) {
      is Max -&gt; MaxExpression(createPhysicalExpr(it.expr, plan.input))
      is Min -&gt; MinExpression(createPhysicalExpr(it.expr, plan.input))
      is Sum -&gt; SumExpression(createPhysicalExpr(it.expr, plan.input))
      else -&gt; throw java.lang.IllegalStateException(
          "Unsupported aggregate function: $it")
    }
  }
  HashAggregateExec(input, groupExpr, aggregateExpr, plan.schema())
}
</code></pre>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询优化"><a class="header" href="#查询优化">查询优化</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>optimizer</code> 模块中找到。</em></p>
<p>我们现在有了功能性的查询计划，但是我们依赖于终端用户以高效的方式构建这些计划。例如，我们期望用户能够构建出尽早进行过滤操作的计划，特别是在联表之前，因为这可以限制需要处理的数据量。</p>
<p>现在是实现一个简单的基于规则的查询优化器的好时机，它可以重新排列查询计划使其更加高效。</p>
<p>一旦我们在第十一章开始支持 SQL，这一点将变得更加重要，因为 SQL 语言仅定义查询应如何工作，并不总是允许用户指定运算符和表达式的计算顺序。</p>
<h2 id="基于规则的优化-rule-based-optimizations"><a class="header" href="#基于规则的优化-rule-based-optimizations">基于规则的优化 Rule-Based Optimizations</a></h2>
<p>基于规则的优化是一种将常识性优化应用于查询计划的简单实用的方法。尽管基于规则的优化也可以应用于物理计划，但这些优化通常在创建物理计划之前针对逻辑计划执行。</p>
<p>优化的工作原理是使用访问者模式遍历逻辑计划，并创建计划中每个步骤的副本并应用任何必要的修改。这是一个比在执行计划时尝试改变状态要简单得多的设计，并且与喜欢不可变状态的函数式编程风格非常一致。</p>
<p>我们将使用以下接口来表示优化器规则。</p>
<pre><code class="language-kotlin">interface OptimizerRule {
  fun optimize(plan: LogicalPlan) : LogicalPlan
}
</code></pre>
<p>现在我们将了解大多数查询引擎实现的一些常见优化规则。</p>
<h3 id="映射下推-projection-push-down"><a class="header" href="#映射下推-projection-push-down">映射下推 Projection Push-Down</a></h3>
<p>映射下推规则的目标是在从磁盘读取数据之后和查询执行的其他阶段之前尽快过滤掉列，以减少操作符之间保留在内存中（以及在分布式场景下可能通过网络传输）的数据量。</p>
<p>为了知道查询中引用了哪些列，我们必须编写递归代码来检查表达式并构建列列表。</p>
<pre><code class="language-kotlin">fun extractColumns(expr: List&lt;LogicalExpr&gt;,
                   input: LogicalPlan,
                   accum: MutableSet&lt;String&gt;) {

  expr.forEach { extractColumns(it, input, accum) }
}

fun extractColumns(expr: LogicalExpr,
                   input: LogicalPlan,
                   accum: MutableSet&lt;String&gt;) {

  when (expr) {
    is ColumnIndex -&gt; accum.add(input.schema().fields[expr.i].name)
    is Column -&gt; accum.add(expr.name)
    is BinaryExpr -&gt; {
       extractColumns(expr.l, input, accum)
       extractColumns(expr.r, input, accum)
    }
    is Alias -&gt; extractColumns(expr.expr, input, accum)
    is CastExpr -&gt; extractColumns(expr.expr, input, accum)
    is LiteralString -&gt; {}
    is LiteralLong -&gt; {}
    is LiteralDouble -&gt; {}
    else -&gt; throw IllegalStateException(
        "extractColumns does not support expression: $expr")
  }
}
</code></pre>
<p>有了这个实用的代码，我们就可以继续实施优化器规则。请注意，对于 <code>Projection</code>、<code>Selection</code> 和 <code>Aggregate</code> 计划，我们正在构建列名列表，但当我们到达 <code>Scan</code>（它是一个叶节点）时，我们将其替换为在查询中其他地方使用的列名列表的扫描版本。</p>
<pre><code class="language-kotlin">class ProjectionPushDownRule : OptimizerRule {

  override fun optimize(plan: LogicalPlan): LogicalPlan {
    return pushDown(plan, mutableSetOf())
  }

  private fun pushDown(plan: LogicalPlan,
                       columnNames: MutableSet&lt;String&gt;): LogicalPlan {
    return when (plan) {
      is Projection -&gt; {
        extractColumns(plan.expr, columnNames)
        val input = pushDown(plan.input, columnNames)
        Projection(input, plan.expr)
      }
      is Selection -&gt; {
        extractColumns(plan.expr, columnNames)
        val input = pushDown(plan.input, columnNames)
        Selection(input, plan.expr)
      }
      is Aggregate -&gt; {
        extractColumns(plan.groupExpr, columnNames)
        extractColumns(plan.aggregateExpr.map { it.inputExpr() }, columnNames)
        val input = pushDown(plan.input, columnNames)
        Aggregate(input, plan.groupExpr, plan.aggregateExpr)
      }
      is Scan -&gt; Scan(plan.name, plan.dataSource, columnNames.toList().sorted())
      else -&gt; throw new UnsupportedOperationException()
    }
  }

}
</code></pre>
<p>给定这个输入逻辑计划：</p>
<pre><code>Projection: #id, #first_name, #last_name
  Filter: #state = 'CO'
    Scan: employee; projection=None
</code></pre>
<p>该优化器规则会将其转换为以下计划。</p>
<pre><code>Projection: #id, #first_name, #last_name
  Filter: #state = 'CO'
    Scan: employee; projection=[first_name, id, last_name, state]
</code></pre>
<h3 id="断言下推-predicate-push-down"><a class="header" href="#断言下推-predicate-push-down">断言下推 Predicate Push-Down</a></h3>
<p>断言下推优化的目的是在查询中尽早过滤掉行，以避免冗余处理。考虑以下内容，联接 <code>employee</code> 表和 <code>dept</code> 表，然后过滤位于科罗拉多州（Colorado）的员工。</p>
<pre><code>Projection: #dept_name, #first_name, #last_name
  Filter: #state = 'CO'
    Join: #employee.dept_id = #dept.id
      Scan: employee; projection=[first_name, id, last_name, state]
      Scan: dept; projection=[id, dept_name]
</code></pre>
<p>该查询将产生正确的结果，但会有执行所有员工（而不仅仅是那些位于科罗拉多州的员工）联接操作所带来的开销。断言下推规则会将过滤器下推到联接中，如下查询计划所示。</p>
<pre><code>Projection: #dept_name, #first_name, #last_name
  Join: #employee.dept_id = #dept.id
    Filter: #state = 'CO'
      Scan: employee; projection=[first_name, id, last_name, state]
    Scan: dept; projection=[id, dept_name]
</code></pre>
<p>联表现在将仅处理一部分员工，从而获得更好的性能。</p>
<h3 id="消除公共子表达式-eliminate-common-subexpressions"><a class="header" href="#消除公共子表达式-eliminate-common-subexpressions">消除公共子表达式 Eliminate Common Subexpressions</a></h3>
<p>给定一个查询如 <code>SELECT sum(price * qty) as total_price, sum(price * qty * tax_rate) as total_tax FROM ...</code>，我们可以看到表达式 <code>price * qty</code> 出现了两次，我们可以选择重写计划只计算一次，而不是执行两次计算。。</p>
<p>原始计划：</p>
<pre><code>Projection: sum(#price * #qty), sum(#price * #qty * #tax)
  Scan: sales
</code></pre>
<p>优化后的计划：</p>
<pre><code>Projection: sum(#_price_mult_qty), sum(#_price_mult_qty * #tax)
  Projection: #price * #qty as _price_mult_qty
    Scan: sales
</code></pre>
<h3 id="将相关子查询转换为联表-converting-correlated-subqueries-to-joins"><a class="header" href="#将相关子查询转换为联表-converting-correlated-subqueries-to-joins">将相关子查询转换为联表 Converting Correlated Subqueries to Joins</a></h3>
<p>给定一个查询如 <code>SELECT id FROM foo WHERE EXISTS (SELECT * FROM bar WHERE foo.id = bar.id)</code>，一个简单的实现可能是扫描 <code>foo</code> 中的所有行，然后对 <code>bar</code> 中查找每一行。这将非常低效，所以查询引擎通常会把相关子查询转化为联表操作。这也被称为子查询去关联。</p>
<p>此查询可以改写为 <code>SELECT foo.id FROM foo JOIN bar ON foo.id = bar.id</code>.</p>
<pre><code>Projection: foo.id
  LeftSemi Join: foo.id = bar.id
    TableScan: foo projection=[id]
    TableScan: bar projection=[id]
</code></pre>
<p>如果查询被修改为使用 <code>NOT EXISTS</code> 而不是 <code>EXISTS</code>，那么查询计划将使用 <code>LeftAnti</code> 而不是 <code>LeftSemi</code> 联接。</p>
<pre><code>Projection: foo.id
  LeftAnti Join: foo.id = bar.id
    TableScan: foo projection=[id]
    TableScan: bar projection=[id]
</code></pre>
<h2 id="基于成本的优化-cost-based-optimizations"><a class="header" href="#基于成本的优化-cost-based-optimizations">基于成本的优化 Cost-Based Optimizations</a></h2>
<p>基于成本的优化是指利用底层数据的统计信息来确定执行特定查询的成本，然后通过寻找成本较低的执行计划来选择最佳执行计划的优化规则。一个好的例子是根据基础表的大小选择要使用的联接算法，或者选择联接表的顺序。</p>
<p>基于成本的优化的一个主要缺点是它们依赖于相关底层数据的准确且详细的统计数据的可用性。此类统计信息通常包括每列统计信息，例如空值的数量、不同值的数量、最小值和最大值以及显示列内值分布的直方图。直方图对于能够检测诸如 <code>state = 'CA'</code> 之类的断言可能产生比 <code>state = 'WY'</code> 更多的行至关重要，比如：（加利福尼亚州是美国人口最多的州，有 3900 万居民，而怀俄明州是人口最少的州，不到 100 万居民）。</p>
<p>当处理 Orc 或 Parquet 等文件格式时，其中一些统计信息是可用的，但通常需要运行一个进程来构建这些统计信息，而当处理 TB 级别的数据时，这可能会令人望而却步，并且得不偿失，特别是对于临时查询。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询执行"><a class="header" href="#查询执行">查询执行</a></h1>
<p>我们现在能够编写代码来对 CSV 文件执行优化的查询。</p>
<p>在使用 KQuery 执行查询之前，使用可信替代方案可能会很有用，这样我们就知道正确的结果应该是什么，并获取一些基线性能指标以供比较。</p>
<h2 id="apache-spark-示例"><a class="header" href="#apache-spark-示例">Apache Spark 示例</a></h2>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>spark</code> 模块中找到。</em></p>
<p>首先，我们需要创建一个 Spark 上下文。请注意，我们使用单线程执行，以便我们可以与 KQuery 中单线程实现的性能进行相对公平的比较。</p>
<pre><code class="language-scala">val spark = SparkSession.builder()
  .master("local[1]")
  .getOrCreate()
</code></pre>
<p>接下来，我们需要根据上下文将 CSV 文件注册为 DataFrame。</p>
<pre><code class="language-scala">val schema = StructType(Seq(
  StructField("VendorID", DataTypes.IntegerType),
  StructField("tpep_pickup_datetime", DataTypes.TimestampType),
  StructField("tpep_dropoff_datetime", DataTypes.TimestampType),
  StructField("passenger_count", DataTypes.IntegerType),
  StructField("trip_distance", DataTypes.DoubleType),
  StructField("RatecodeID", DataTypes.IntegerType),
  StructField("store_and_fwd_flag", DataTypes.StringType),
  StructField("PULocationID", DataTypes.IntegerType),
  StructField("DOLocationID", DataTypes.IntegerType),
  StructField("payment_type", DataTypes.IntegerType),
  StructField("fare_amount", DataTypes.DoubleType),
  StructField("extra", DataTypes.DoubleType),
  StructField("mta_tax", DataTypes.DoubleType),
  StructField("tip_amount", DataTypes.DoubleType),
  StructField("tolls_amount", DataTypes.DoubleType),
  StructField("improvement_surcharge", DataTypes.DoubleType),
  StructField("total_amount", DataTypes.DoubleType)
))

val tripdata = spark.read.format("csv")
  .option("header", "true")
  .schema(schema)
  .load("/mnt/nyctaxi/csv/yellow_tripdata_2019-01.csv")

tripdata.createOrReplaceTempView("tripdata")
</code></pre>
<p>最后，我们可以开始针对 DataFrame 执行 SQL。</p>
<pre><code class="language-scala">val start = System.currentTimeMillis()

val df = spark.sql(
  """SELECT passenger_count, MAX(fare_amount)
    |FROM tripdata
    |GROUP BY passenger_count""".stripMargin)

df.foreach(row =&gt; println(row))

val duration = System.currentTimeMillis() - start

println(s"Query took $duration ms")
</code></pre>
<p>在我的桌面电脑上执行此代码会生成以下输出。</p>
<pre><code>[1,623259.86]
[6,262.5]
[3,350.0]
[5,760.0]
[9,92.0]
[4,500.0]
[8,87.0]
[7,78.0]
[2,492.5]
[0,36090.3]
Query took 14418 ms
</code></pre>
<h2 id="kquery-示例"><a class="header" href="#kquery-示例">KQuery 示例</a></h2>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>examples</code> 模块中找到。</em></p>
<p>这是使用 KQuery 实现的等效查询。请注意，此代码与 Spark 示例不同，因为 KQuery 还没有指定 CSV 文件结构的选项，因此所有数据类型都是字符串，这意味着我们需要向查询计划添加显式转换以将 <code>fare_amount</code> 列转换为数字类型。</p>
<pre><code class="language-kotlin">val time = measureTimeMillis {

val ctx = ExecutionContext()

val df = ctx.csv("/mnt/nyctaxi/csv/yellow_tripdata_2019-01.csv", 1*1024)
            .aggregate(
               listOf(col("passenger_count")),
               listOf(max(cast(col("fare_amount"), ArrowTypes.FloatType))))

val optimizedPlan = Optimizer().optimize(df.logicalPlan())
val results = ctx.execute(optimizedPlan)

results.forEach { println(it.toCSV()) }

println("Query took $time ms")
</code></pre>
<p>在我的桌面电脑上会生成以下输出。</p>
<pre><code>Schema&lt;passenger_count: Utf8, MAX: FloatingPoint(DOUBLE)&gt;
1,623259.86
2,492.5
3,350.0
4,500.0
5,760.0
6,262.5
7,78.0
8,87.0
9,92.0
0,36090.3

Query took 6740 ms
</code></pre>
<p>我们可以看到结果与 Apache Spark 生成的结果相匹配。我们还发现，对于这种大小的输入，性能相当不错。Apache Spark 在处理更大的数据集时很可能会优于 KQuery，因为它针对“大数据”进行了优化。</p>
<h2 id="删除查询优化器"><a class="header" href="#删除查询优化器">删除查询优化器</a></h2>
<p>让我们删除优化，看看它们对性能有多大帮助。</p>
<pre><code class="language-kotlin">val time = measureTimeMillis {

val ctx = ExecutionContext()

val df = ctx.csv("/mnt/nyctaxi/csv/yellow_tripdata_2019-01.csv", 1*1024)
            .aggregate(
               listOf(col("passenger_count")),
               listOf(max(cast(col("fare_amount"), ArrowTypes.FloatType))))

val results = ctx.execute(df.logicalPlan())

results.forEach { println(it.toCSV()) }

println("Query took $time ms")
</code></pre>
<p>在我的桌面电脑上会生成以下输出。</p>
<pre><code>1,623259.86
2,492.5
3,350.0
4,500.0
5,760.0
6,262.5
7,78.0
8,87.0
9,92.0
0,36090.3

Query took 36090 ms
</code></pre>
<p>结果是相同的，但查询的执行时间大约是原来的五倍。这清楚地显示了前一章讨论的映射下推优化的好处。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-支持"><a class="header" href="#sql-支持">SQL 支持</a></h1>
<p><em>本章所讨论的源代码可以在 <a href="https://github.com/andygrove/how-query-engines-work">KQuery 项目</a> 的 <code>sql</code> 模块中找到。</em></p>
<p>除了能够手写逻辑计划之外，在某些情况下只编写 SQL 会更方便。在本章中，我们将构建一个 SQL 解析器和查询计划器，可以将 SQL 查询转换为逻辑计划。</p>
<h2 id="分词器-tokenizer"><a class="header" href="#分词器-tokenizer">分词器 Tokenizer</a></h2>
<p>第一步是将 SQL 查询字符串转换为表示关键字、字面量、标识符和运算符的标记列表。</p>
<p>这只是所有可能标记的子集，但现在已经足够了。</p>
<pre><code class="language-kotlin">interface Token
data class IdentifierToken(val s: String) : Token
data class LiteralStringToken(val s: String) : Token
data class LiteralLongToken(val s: String) : Token
data class KeywordToken(val s: String) : Token
data class OperatorToken(val s: String) : Token
</code></pre>
<p>然后我们需要一个分词器类。在这里没有特别必要完整的过一遍，完整的源代码可以在配套的 GitHub 代码库中找到。</p>
<pre><code class="language-kotlin">class Tokenizer {
  fun tokenize(sql: String): List&lt;Token&gt; {
    // see github repo for code
  }
}
</code></pre>
<p>给定输入 <code>"SELECT a + b FROM c"</code> 我们期望输出如下：</p>
<pre><code class="language-kotlin">listOf(
  KeywordToken("SELECT"),
  IdentifierToken("a"),
  OperatorToken("+"),
  IdentifierToken("b"),
  KeywordToken("FROM"),
  IdentifierToken("c")
)
</code></pre>
<h2 id="pratt-解析器"><a class="header" href="#pratt-解析器">Pratt 解析器</a></h2>
<p>我们将根据 Vaughan R. Pratt 于 1973 年发表的 <a href="https://tdop.github.io/">Top Down Operator Precedence</a> 论文手动编写 SQL 解析器。尽管还有其他方法来构建 SQL 解析器，例如使用解析器生成器和解析器组合器，但我发现了 Pratt 的方法工作良好，代码高效、易于理解且易于调试。</p>
<p>这是 Pratt 解析器的简单实现。在我看来，它的美丽在于它的简单。表达式解析是通过一个简单的循环来执行的，该循环解析“前缀”表达式，后跟一个可选的“中缀”表达式，并继续执行此操作，直到优先级发生变化，使解析器认识到它已完成对表达式的解析。当然，<code>parsePrefix</code> 和 <code>parseInfix</code> 的实现可以递归地回调  <code>parse</code> 方法，这就是它变得非常强大的地方。</p>
<pre><code class="language-kotlin">interface PrattParser {

  /** Parse an expression */
  fun parse(precedence: Int = 0): SqlExpr? {
    var expr = parsePrefix() ?: return null
    while (precedence &lt; nextPrecedence()) {
      expr = parseInfix(expr, nextPrecedence())
    }
    return expr
  }

  /** Get the precedence of the next token */
  fun nextPrecedence(): Int

  /** Parse the next prefix expression */
  fun parsePrefix(): SqlExpr?

  /** Parse the next infix expression */
  fun parseInfix(left: SqlExpr, precedence: Int): SqlExpr

}
</code></pre>
<p>该接口引用一个新 <code>SqlExpr</code> 类，它将作为解析表达式的表示，并且很大程度上会与逻辑计划中定义的表达式一一对应，但对于二元表达式，我们可以使用更通用的结构，其中运算符是字符串而不是为所有不同二元表达式创建单独数据结构。</p>
<p>以下是一些实现 <code>SqlExpr</code> 的例子。</p>
<pre><code class="language-kotlin">/** SQL Expression */
interface SqlExpr

/** Simple SQL identifier such as a table or column name */
data class SqlIdentifier(val id: String) : SqlExpr {
  override fun toString() = id
}

/** Binary expression */
data class SqlBinaryExpr(val l: SqlExpr, val op: String, val r: SqlExpr) : SqlExpr {
  override fun toString(): String = "$l $op $r"
}

/** SQL literal string */
data class SqlString(val value: String) : SqlExpr {
  override fun toString() = "'$value'"
}
</code></pre>
<p>有了这些类后，就可以用下面代码表示 <code>foo = 'bar'</code>。</p>
<pre><code class="language-kotlin">val sqlExpr = SqlBinaryExpr(SqlIdentifier("foo"), "=", SqlString("bar"))
</code></pre>
<h2 id="解析-sql-表达式"><a class="header" href="#解析-sql-表达式">解析 SQL 表达式</a></h2>
<p>让我们通过解析一个简单的数学表达式 <code>1 + 2 * 3</code> 来逐步了解这种方法，该表达式由以下标记组成。</p>
<pre><code class="language-kotlin">listOf(
  LiteralLongToken("1"),
  OperatorToken("+"),
  LiteralLongToken("2"),
  OperatorToken("*"),
  LiteralLongToken("3")
)
</code></pre>
<p>我们需要创建一个实现了 <code>PrattParser</code> 特性（trait） 的对象，并将标记（tokens）传入构造函数。这些标记（tokens）被包装在一个 <code>TokenStream</code> 类中，该类提供了一些方便的方法，例如<code>next</code> 用于消耗下一个标记（tokens），以及 <code>peek</code> 当我们想要向前查看而不消耗标记（token）时。</p>
<pre><code class="language-kotlin">class SqlParser(val tokens: TokenStream) : PrattParser {
}
</code></pre>
<p>实现 <code>nextPrecedence</code> 方法很简单，因为我们只有少量具有优先级的标记（token），我们需要让<code>乘法</code> 和 <code>除法</code> 运算符具有比 <code>加法</code> 和 <code>减法</code> 运算符更高的优先级。请注意，此方法返回的具体数字并不重要，因为它们仅用于比较。关于运算符优先级的一个很好的参考可以在 <a href="https://www.postgresql.org/docs/7.2/sql-precedence.html">PostgreSQL documentation</a> 中找到。</p>
<pre><code class="language-kotlin">override fun nextPrecedence(): Int {
  val token = tokens.peek()
  return when (token) {
    is OperatorToken -&gt; {
      when (token.s) {
        "+", "-" -&gt; 50
        "*", "/" -&gt; 60
        else -&gt; 0
      }
    }
    else -&gt; 0
  }
}
</code></pre>
<p>前缀解析器只需要知道如何解析字面数值。</p>
<pre><code class="language-kotlin">override fun parsePrefix(): SqlExpr? {
  val token = tokens.next() ?: return null
  return when (token) {
    is LiteralLongToken -&gt; SqlLong(token.s.toLong())
    else -&gt; throw IllegalStateException("Unexpected token $token")
  }
}
</code></pre>
<p>中缀解析器只需要知道如何解析运算符。请注意，解析运算符后，此方法会递归回调上层的 <code>parse</code> 方法来解析运算符后面的表达式（二元表达式的右侧）。</p>
<pre><code class="language-kotlin">override fun parseInfix(left: SqlExpr, precedence: Int): SqlExpr {
  val token = tokens.peek()
  return when (token) {
    is OperatorToken -&gt; {
      tokens.next()
      SqlBinaryExpr(left, token.s, parse(precedence) ?:
                    throw SQLException("Error parsing infix"))
    }
    else -&gt; throw IllegalStateException("Unexpected infix token $token")
  }
}
</code></pre>
<p>优先级逻辑可以通过解析数学表达式 <code>1 + 2 * 3</code> 和 <code>1 * 2 + 3</code> 来演示，它们应该被分别解析为 <code>1 + (2 * 3)</code> 和 <code>(1 * 2) + 3</code>。</p>
<p><em>示例: 解析 <code>1 + 2 _ 3</code></em></p>
<p>这些是标记及其优先级值。</p>
<pre><code>Tokens:      [1]  [+]  [2]  [*]  [3]
Precedence:  [0] [50]  [0] [60]  [0]
</code></pre>
<p>最终结果正确地将表达式表示为 <code>1 + (2 * 3)</code>。</p>
<pre><code class="language-kotlin">SqlBinaryExpr(
    SqlLong(1),
    "+",
    SqlBinaryExpr(SqlLong(2), "*", SqlLong(3))
)
</code></pre>
<p><em>示例: 解析 <code>1 _ 2 + 3</code></em></p>
<pre><code>Tokens:      [1]  [*]  [2]  [+]  [3]
Precedence:  [0] [60]  [0] [50]  [0]
</code></pre>
<p>最终结果正确地将表达式表示为 <code>(1 * 2) + 3</code>。</p>
<pre><code class="language-kotlin">SqlBinaryExpr(
    SqlBinaryExpr(SqlLong(1), "*", SqlLong(2)),
    "+",
    SqlLong(3)
)
</code></pre>
<h2 id="解析-select-语句"><a class="header" href="#解析-select-语句">解析 SELECT 语句</a></h2>
<p>现在我们已经能够解析一些简单的表达式，下一步是扩展解析器以支持将 SELECT 语句解析为具体语法树 (CST)。请注意，使用其他解析方法（例如使用像 ANTLR 这样的解析器生成器）时，有一个称为抽象语法树（AST）的中间阶段，然后需要将其转换为具体语法树，但使用 Pratt 解析器方法，我们直接从标记（tokens）生成 CST。</p>
<p>下面是一个示例 CST，它可以表示带有映射（projection）和筛选（selection）的简单单表查询。将在后面的章节中扩展以支持更复杂的查询。</p>
<pre><code class="language-kotlin">data class SqlSelect(
    val projection: List&lt;SqlExpr&gt;,
    val selection: SqlExpr,
    val tableName: String) : SqlRelation
</code></pre>
<h2 id="sql-查询规划器-query-planner"><a class="header" href="#sql-查询规划器-query-planner">SQL 查询规划器 Query Planner</a></h2>
<p>SQL 查询规划器将 SQL 查询树转换为逻辑计划。由于 SQL 语言的灵活性，这比将逻辑计划转换为物理计划要困难得多。例如，考虑以下简单查询。</p>
<pre><code class="language-sql">SELECT id, first_name, last_name, salary/12 AS monthly_salary
FROM employee
WHERE state = 'CO' AND monthly_salary &gt; 1000
</code></pre>
<p>尽管这对于阅读查询的人来说很直观，但查询的选择部分（<code>WHERE</code>子句）引用了一个不包含在映射（selection）输出中的表达式（<code>state</code>），因此显然需要在投影之前应用它，同时还引用另一个表达式（<code>salary/12 AS monthly_salary</code>) 仅在应用映射后才可用。我们还会遇到类似 <code>GROUP BY</code>, <code>HAVING</code>, 和 <code>ORDER BY</code> 子句等问题。</p>
<p>这个问题有多种解决方案。一种方法是将此查询转换为以下逻辑计划，将选择表达式分为两个步骤，一个在映射之前，一个在映射之后。然而，只有当选择表达式是连接性断言（conjunctive predicate）（即所有部分都为真时，表达式才为真）时这种方法才可能行得通，对于更复杂的表达式来说，这种方法可能就不适用了。如果表达式是 <code>state = 'CO' OR monthly_salary &gt; 1000</code> 那么我们就不能这样做。</p>
<pre><code>Filter: #monthly_salary &gt; 1000
  Projection: #id, #first_name, #last_name, #salary/12 AS monthly_salary
    Filter: #state = 'CO'
      Scan: table=employee
</code></pre>
<p>一种更简单、更通用的方法是将所有必需的表达式添加到映射（projection），以便可以在映射之后应用选择（selection），然后删除 通过将输出包装在另一个映射中而添加的列。</p>
<pre><code>Projection: #id, #first_name, #last_name, #monthly_salary
  Filter: #state = 'CO' AND #monthly_salary &gt; 1000
    Projection: #id, #first_name, #last_name, #salary/12 AS monthly_salary, #state
      Scan: table=employee
</code></pre>
<p>值得注意的是，我们将在后面的章节中构建一个“断言下推（Predicate Push Down）”查询优化器规则，该规则将能够优化该计划并将 <code>state = 'CO'</code> 断言部分在计划中进一步下推，使其位于映射之前。</p>
<h2 id="转换-sql-表达式"><a class="header" href="#转换-sql-表达式">转换 SQL 表达式</a></h2>
<p>将 SQL 表达式转换为逻辑表达式相当简单，如本示例代码所示。</p>
<pre><code class="language-kotlin">private fun createLogicalExpr(expr: SqlExpr, input: DataFrame) : LogicalExpr {
  return when (expr) {
    is SqlIdentifier -&gt; Column(expr.id)
    is SqlAlias -&gt; Alias(createLogicalExpr(expr.expr, input), expr.alias.id)
    is SqlString -&gt; LiteralString(expr.value)
    is SqlLong -&gt; LiteralLong(expr.value)
    is SqlDouble -&gt; LiteralDouble(expr.value)
    is SqlBinaryExpr -&gt; {
      val l = createLogicalExpr(expr.l, input)
      val r = createLogicalExpr(expr.r, input)
      when(expr.op) {
        // comparison operators
        "=" -&gt; Eq(l, r)
        "!=" -&gt; Neq(l, r)
        "&gt;" -&gt; Gt(l, r)
        "&gt;=" -&gt; GtEq(l, r)
        "&lt;" -&gt; Lt(l, r)
        "&lt;=" -&gt; LtEq(l, r)
        // boolean operators
        "AND" -&gt; And(l, r)
        "OR" -&gt; Or(l, r)
        // math operators
        "+" -&gt; Add(l, r)
        "-" -&gt; Subtract(l, r)
        "*" -&gt; Multiply(l, r)
        "/" -&gt; Divide(l, r)
        "%" -&gt; Modulus(l, r)
        else -&gt; throw SQLException("Invalid operator ${expr.op}")
      }
    }

    else -&gt; throw new UnsupportedOperationException()
  }
}
</code></pre>
<h2 id="规划选择"><a class="header" href="#规划选择">规划选择</a></h2>
<p>如果我们只想支持所有在选择中引用的列也存在于映射中的用例，我们可以通过一些非常简单的逻辑来构建查询计划。</p>
<pre><code class="language-kotlin">fun createDataFrame(select: SqlSelect, tables: Map&lt;String, DataFrame&gt;) : DataFrame {

  // get a reference to the data source
  var df = tables[select.tableName] ?:
      throw SQLException("No table named '${select.tableName}'")

  val projectionExpr = select.projection.map { createLogicalExpr(it, df) }

  if (select.selection == null) {
    // apply projection
    return df.select(projectionExpr)
  }

  // apply projection then wrap in a selection (filter)
  return df.select(projectionExpr)
           .filter(createLogicalExpr(select.selection, df))
}
</code></pre>
<p>然而，由于选择可能同时引用映射的输入和输出，因此我们需要创建一个更复杂的带有中间投影的计划。第一步是确定哪些列被选择过滤表达式引用。为此，我们将使用访问者模式来遍历表达式树并构建一个可变的列名称集合。</p>
<p>以下是我们将用来遍历表达式树的实用方法。</p>
<pre><code class="language-kotlin">private fun visit(expr: LogicalExpr, accumulator: MutableSet&lt;String&gt;) {
  when (expr) {
    is Column -&gt; accumulator.add(expr.name)
    is Alias -&gt; visit(expr.expr, accumulator)
    is BinaryExpr -&gt; {
      visit(expr.l, accumulator)
      visit(expr.r, accumulator)
     }
  }
}
</code></pre>
<p>有了这个，我们现在可以编写以下代码将 SELECT 语句转换为有效的逻辑计划。此代码示例并不完美，可能包含一些边缘情况的错误，其中数据源中的列和别名表达式之间存在名称冲突，但是为了保持代码简洁暂时忽略它们。</p>
<pre><code class="language-kotlin">fun createDataFrame(select: SqlSelect, tables: Map&lt;String, DataFrame&gt;) : DataFrame {

  // get a reference to the data source
  var df = tables[select.tableName] ?:
    throw SQLException("No table named '${select.tableName}'")

  // create the logical expressions for the projection
  val projectionExpr = select.projection.map { createLogicalExpr(it, df) }

  if (select.selection == null) {
    // if there is no selection then we can just return the projection
    return df.select(projectionExpr)
  }

  // create the logical expression to represent the selection
  val filterExpr = createLogicalExpr(select.selection, df)

  // get a list of columns references in the projection expression
  val columnsInProjection = projectionExpr
    .map { it.toField(df.logicalPlan()).name}
    .toSet()

  // get a list of columns referenced in the selection expression
  val columnNames = mutableSetOf&lt;String&gt;()
  visit(filterExpr, columnNames)

  // determine if the selection references any columns not in the projection
  val missing = columnNames - columnsInProjection

  // if the selection only references outputs from the projection we can
  // simply apply the filter expression to the DataFrame representing
  // the projection
  if (missing.size == 0) {
    return df.select(projectionExpr)
             .filter(filterExpr)
  }

  // because the selection references some columns that are not in the
  // projection output we need to create an interim projection that has
  // the additional columns and then we need to remove them after the
  // selection has been applied
  return df.select(projectionExpr + missing.map { Column(it) })
           .filter(filterExpr)
           .select(projectionExpr.map {
              Column(it.toField(df.logicalPlan()).name)
            })
}
</code></pre>
<h2 id="规划聚合查询"><a class="header" href="#规划聚合查询">规划聚合查询</a></h2>
<p>如你所见，SQL查询规划器相对复杂，解析聚合查询的代码也颇多。如果你对此感兴趣，请参阅源代码。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="执行并发查询"><a class="header" href="#执行并发查询">执行并发查询</a></h1>
<p>到目前为止，我们一直使用单个线程来对单个文件执行查询。这种方法的可扩展性不是很强，因为对于较大的文件或多个文件，查询将需要更长的时间来运行。下一步是实现分布式查询执行，以便查询执行可以利用多个CPU核心和多个服务器。</p>
<p>分布式查询执行的最简单形式是使用线程在单个节点上利用多个 CPU 核心并行查询执行。</p>
<p>纽约市出租车数据集已经方便地进行分区，因为每年每个月都有一个 CSV 文件，这意味着例如 2019 年数据集有 12 个分区。并行查询执行的最直接方法是每个分区使用一个线程并行执行相同的查询，然后合并结果。假设此代码运行在有六个 CPU 核心且支持超线程的计算机上。在这种情况下，假设每个月都有相似的数据量，那么这 12 个查询的执行时间应该与在单个线程上运行其中一个查询的时间相同。</p>
<p>以下是在 12 个分区并行运行聚合 SQL 查询的示例。本示例是使用 Kotlin 协程实现的，而不是直接使用线程。</p>
<p>此示例的源代码可以在 KQuery GitHub 仓库的 <code>jvm/examples/src/main/kotlin/ParallelQuery.kt</code> 中找到。</p>
<p>让我们从针对一个分区运行一个查询的单线程代码开始。</p>
<pre><code class="language-kotlin">fun executeQuery(path: String, month: Int, sql: String): List&lt;RecordBatch&gt; {
  val monthStr = String.format("%02d", month);
  val filename = "$path/yellow_tripdata_2019-$monthStr.csv"
  val ctx = ExecutionContext()
  ctx.registerCsv("tripdata", filename)
  val df = ctx.sql(sql)
  return ctx.execute(df).toList()
}
</code></pre>
<p>有了这个，我们现在可以编写以下代码来并行运行 12 个分区数据的查询。</p>
<pre><code class="language-kotlin">val start = System.currentTimeMillis()
val deferred = (1..12).map {month -&gt;
  GlobalScope.async {

    val sql = "SELECT passenger_count, " +
        "MAX(CAST(fare_amount AS double)) AS max_fare " +
        "FROM tripdata " +
        "GROUP BY passenger_count"

    val start = System.currentTimeMillis()
    val result = executeQuery(path, month, sql)
    val duration = System.currentTimeMillis() - start
    println("Query against month $month took $duration ms")
    result
  }
}
val results: List&lt;RecordBatch&gt; = runBlocking {
  deferred.flatMap { it.await() }
}
val duration = System.currentTimeMillis() - start
println("Collected ${results.size} batches in $duration ms")
</code></pre>
<p>这是在一台具有 <em>24核心</em> 的桌面电脑上运行此示例的输出结果。</p>
<pre><code>Query against month 8 took 17074 ms
Query against month 9 took 18976 ms
Query against month 7 took 20010 ms
Query against month 2 took 21417 ms
Query against month 11 took 21521 ms
Query against month 12 took 22082 ms
Query against month 6 took 23669 ms
Query against month 1 took 23735 ms
Query against month 10 took 23739 ms
Query against month 3 took 24048 ms
Query against month 5 took 24103 ms
Query against month 4 took 25439 ms
Collected 12 batches in 25505 ms
</code></pre>
<p>如你所见，总持续时间与最慢查询的时间大致相同。</p>
<p>尽管我们已经成功地对分区执行了聚合查询，但我们的结果是具有重复值的批次数据的列表。例如，每个分区很可能都会产生<code>passenger_count=1</code> 的结果。</p>
<h2 id="合并结果"><a class="header" href="#合并结果">合并结果</a></h2>
<p>对于由映射和选择运算符组成的简单查询，可以组合并行查询的结果（类似于SQL <code>UNION ALL</code> 操作），并且不需要进一步处理。涉及聚合、排序或联表的更复杂的查询将需要对并行查询的结果运行辅助查询以合并结果。术语 “map” 和 “reduce” 经常用来解释这个两步过程。 “map” 步骤是指跨分区并行运行一个查询，“reduce” 步骤是指将结果合并为单个结果。</p>
<p>对于这个特定的示例，现在需要运行与针对分区执行的聚合查询几乎相同的辅助聚合查询。一个区别是第二个查询可能需要应用不同的聚合函数。对于聚合函数 <code>min</code>、<code>max</code> 和 <code>sum</code> 在映射和归约步骤中使用相同的操作，以获得最小值的最小值或总和的总和。对于计数表达式，我们不需要计数结果的数量。我们希望看到所有计数的总和。</p>
<pre><code class="language-kotlin">val sql = "SELECT passenger_count, " +
        "MAX(max_fare) " +
        "FROM tripdata " +
        "GROUP BY passenger_count"

val ctx = ExecutionContext()
ctx.registerDataSource("tripdata", InMemoryDataSource(results.first().schema, results))
val df = ctx.sql(sql)
ctx.execute(df).forEach { println(it) }
</code></pre>
<p>这会产生最终结果集：</p>
<pre><code>1,671123.14
2,1196.35
3,350.0
4,500.0
5,760.0
6,262.5
7,80.52
8,89.0
9,97.5
0,90000.0
</code></pre>
<h2 id="更智能的分区"><a class="header" href="#更智能的分区">更智能的分区</a></h2>
<p>尽管每个文件使用一个线程的策略在此示例中效果很好，但它不能作为一种通用的分区方法。如果一个数据源有数千个小分区，那么每个分区启动一个线程将不会高效。更好的方法是让查询规划器决定如何在指定数量的工作线程（或执行器）之间共享可用数据。</p>
<p>某些文件格式已经天然具有分区方案。例如，Apache Parquet 文件由多个包含批量列式数据的 “行组” 组成。查询规划器可以检查可用的 Parquet 文件，构建行组列表，然后安排固定数量的线程或执行器读取这些行组。</p>
<p>甚至可以将此技术应用于非结构化文件（例如 CSV 文件），但这并非易事。检查文件大小并将文件分成大小相等的块很容易，但一条记录可能跨越两个块，因此有必要从边界向后或向前读取以找到记录的开头或结尾。查找换行符是不够的，因为它们经常出现在记录中，并且也用于分隔记录。通常的做法是在处理管道中尽早将 CSV 文件转换为结构化格式（例如 Parquet），以提高后续处理的效率。</p>
<h2 id="分区键"><a class="header" href="#分区键">分区键</a></h2>
<p>解决这个问题的一种方法是将文件放在目录中，并使用由键值对组成的目录名称来指定内容。</p>
<p>例如，我们可以按如下方式组织文件：</p>
<pre><code>/mnt/nyxtaxi/csv/year=2019/month=1/tripdata.csv
/mnt/nyxtaxi/csv/year=2019/month=2/tripdata.csv
...
/mnt/nyxtaxi/csv/year=2019/month=12/tripdata.csv
</code></pre>
<p>有了这个结构，查询计划程序现在可以实现一种 “谓词下推（predicate push down）” 形式，以限制物理查询计划中包含的分区数量。这种方法通常称为“分区修剪（partition pruning）”。</p>
<h2 id="并发联表"><a class="header" href="#并发联表">并发联表</a></h2>
<p>当用单线程执行内连接时，一个简单的方法是将连接的一侧加载到内存中，然后扫描另一侧，在内存中存储的数据上进行查找。如果连接的一方能够装入内存，则此经典哈希连接算法非常高效。</p>
<p>其并行版本称为分区哈希连接或并行哈希连接。它涉及根据连接键对两个输入进行分区，并对每对输入分区执行经典的哈希连接。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="执行分布式查询"><a class="header" href="#执行分布式查询">执行分布式查询</a></h1>
<p>上一节有关并行查询执行的内容介绍了一些基本概念，例如分区，我们将在本节中进一步展开。</p>
<p>为了简化分布式查询执行的概念，其目标是能够创建一个物理查询计划，该计划定义了如何将工作分配给集群中的多个“执行器”。分布式查询计划通常会包含新的操作符，这些操作符描述了在查询执行过程中各个点上数据如何在执行器之间交换。</p>
<p>在接下来的部分中，我们将探讨不同类型的计划如何在分布式环境中执行，然后讨论构建一个分布式查询调度器。</p>
<h2 id="令人尴尬的并行运算符"><a class="header" href="#令人尴尬的并行运算符">令人尴尬的并行运算符</a></h2>
<p>在分布式环境中运行时，某些运算符可以在数据分区上并行运行，而几乎不产生任何显著开销。其中最好的例子是映射（Projection）和过滤（Filter）。这些运算符可以并行应用于正在操作的数据的每个输入分区，并为每个分区生成相应的输出分区。这些运算符不会更改数据的分区方案。</p>
<p><img src="images/distributed_project_filter.png" alt="distributed project filter" /></p>
<h2 id="分布式聚合"><a class="header" href="#分布式聚合">分布式聚合</a></h2>
<p>让我们使用上一章并行查询执行中使用的示例 SQL 查询，看看聚合查询的分布式计划含义。</p>
<pre><code class="language-sql">SELECT passenger_count, MAX(max_fare)
FROM tripdata
GROUP BY passenger_count
</code></pre>
<p>我们可以在 <code>tripdata</code> 表的所有分区上并行地执行此查询，集群中的每个执行器处理这些分区的子集。但是，我们需要将所有生成的聚合数据组合到单个节点上，然后应用最终的聚合查询，以便我们获得没有重复分组键的单个结果集（<code>passenger_count</code> 在本例中）。这是表示这一点的一种可能的逻辑查询计划。请注意 <code>newExchange</code> 运算符，它代表执行器之间的数据交换。交换的物理计划可以通过将中间结果写入共享存储来实现，或者可以通过将数据直接流式传输到其他执行器来实现。</p>
<pre><code>HashAggregate: groupBy=[passenger_count], aggr=[MAX(max_fare)]
  Exchange:
    HashAggregate: groupBy=[passenger_count], aggr=[MAX(max_fare)]
      Scan: tripdata.parquet
</code></pre>
<p>下图显示了如何在分布式环境中执行此查询：</p>
<p><img src="images/distributed_agg.png" alt="distributed agg" /></p>
<h2 id="分布式联表"><a class="header" href="#分布式联表">分布式联表</a></h2>
<p>联表通常是分布式环境中执行成本最高的操作。原因是我们需要确保以这样的方式组织数据，即两个输入关系都在联表键上进行分区。例如，如果我们要将一个 <code>customer</code> 表连接到一个 <code>order</code>表 其联表条件为 <code>customer.id = order.customer_id</code>，那么两个表中针对特定客户的所有行必须由同一个执行器处理。为了实现这一点，我们必须首先在联表键上对两个表进行重新分区，并将分区写入磁盘。一旦完成，我们就可以并行执行联表，每个分区执行一个连接。结果数据将保持按联表键分区。这种特殊的联表算法称为分区哈希联表。重新分区数据的过程称为执行 “shuffle”。</p>
<p><img src="images/distributed_join.png" alt="distributed join" /></p>
<h2 id="分布式查询调度"><a class="header" href="#分布式查询调度">分布式查询调度</a></h2>
<p>分布式查询计划与进程内查询计划有着根本的不同，因为我们不能仅仅构建一个运算符树并开始执行它们。查询现在需要跨执行器进行协调，这意味着我们现在需要构建一个调度器。</p>
<p>从高层次来看，分布式查询调度器的概念并不复杂。调度器需要检查整个查询并将其分解为可以独立执行的阶段（通常在执行器之间并行），然后根据集群中的可用资源调度这些阶段的执行。每个查询阶段完成后，就可以安排任何后续的相关查询阶段。重复此过程直到执行完所有查询阶段。</p>
<p>调度器还可以负责管理集群中的计算资源，以便可以根据需要启动额外的执行程序来处理查询负载。</p>
<p>在本章的剩余部分中，我们将讨论以下主题，参考 <code>Ballista</code> 以及该项目中正在实施的设计：</p>
<ul>
<li>生成一个分布式查询计划</li>
<li>序列化查询计划并与执行器交换</li>
<li>在各个执⾏器之间交换中间结果</li>
<li>优化分布式查询</li>
</ul>
<h2 id="生成一个分布式查询计划"><a class="header" href="#生成一个分布式查询计划">生成一个分布式查询计划</a></h2>
<p>正如我们在前面的示例中所看到的，某些运算符可以在输入分区上并行运行，而某些运算符则需要对数据进行重新分区。这些分区的变化是规划分布式查询的关键。计划内部的分区变化有时被称为管道断路器，这些分区的变化定义了查询阶段之间的边界。</p>
<p>我们现在将使用以下 SQL 查询来查看此过程是如何工作的。</p>
<pre><code class="language-sql">SELECT customer.id, sum(order.amount) as total_amount
FROM customer JOIN order ON customer.id = order.customer_id
GROUP BY customer.id
</code></pre>
<p>该查询的物理（非分布式）计划如下所示：</p>
<pre><code>Projection: #customer.id, #total_amount
  HashAggregate: groupBy=[customer.id], aggr=[MAX(max_fare) AS total_amount]
    Join: condition=[customer.id = order.customer_id]
      Scan: customer
      Scan: order
</code></pre>
<p>假设 <code>customer</code>表 和 <code>order</code> 表尚未根据 <code>customer_id</code> 进行分区，我们需要安排前两个查询阶段的执行来重新分区该数据。这两个查询阶段可以并行运行。</p>
<pre><code>Query Stage #1: repartition=[customer.id]
  Scan: customer
Query Stage #2: repartition=[order.customer_id]
  Scan: order
</code></pre>
<p>接下来，我们可以安排联表，该联表将为两个输入的每个分区并行运行。联表后的下一个运算符是聚合，它分为两部分；并行运行的聚合，然后是需要单个输入分区的最终聚合。我们可以在与联表相同的查询阶段执行此聚合的并行部分，因为第一个聚合不关心数据如何分区。这给了我们第三个查询阶段，现在可以安排执行。此查询阶段的输出仍然按 <code>customer_id</code> 分区。</p>
<pre><code>Query Stage #3: repartition=[]
  HashAggregate: groupBy=[customer.id], aggr=[MAX(max_fare) AS total_amount]
    Join: condition=[customer.id = order.customer_id]
      Query Stage #1
      Query Stage #2
</code></pre>
<p>最后的查询阶段执行聚合的聚合，从前一阶段的所有分区中读取。</p>
<pre><code>Query Stage #4:
  Projection: #customer.id, #total_amount
    HashAggregate: groupBy=[customer.id], aggr=[MAX(max_fare) AS total_amount]
      QueryStage #3
</code></pre>
<p>回顾一下，这里是完整的分布式查询计划，显示了当数据需要在管道操作之间重新分区或交换时引入的查询阶段。</p>
<pre><code>Query Stage #4:
  Projection: #customer.id, #total_amount
    HashAggregate: groupBy=[customer.id], aggr=[MAX(max_fare) AS total_amount]
      Query Stage #3: repartition=[]
        HashAggregate: groupBy=[customer.id], aggr=[MAX(max_fare) AS total_amount]
          Join: condition=[customer.id = order.customer_id]
            Query Stage #1: repartition=[customer.id]
              Scan: customer
            Query Stage #2: repartition=[order.customer_id]
              Scan: order
</code></pre>
<h2 id="序列化查询计划"><a class="header" href="#序列化查询计划">序列化查询计划</a></h2>
<p>查询调度器需要将整个查询计划的片段发送给执行器来执行。</p>
<p>有许多选项可用于序列化查询计划，以便它可以在进程之间传递。许多查询引擎选择使用编程语言本身序列化支持的策略，如果不需要能够在不同编程语言之间交换查询计划，那么这是一个合适的选择，并且这通常是最简单的实现机制。</p>
<p>但是，使用与编程语言无关的序列化格式有一些优点。<code>Ballista</code> 使用 Google 的 <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> 格式来定义查询计划。该项目通常缩写为 “protobuf”。</p>
<p>以下是查询计划的 <code>Ballista</code> 协议缓冲区定义的子集。</p>
<p>完整的源代码可以在 Ballista github 存储库中 <code>proto/ballista.proto</code> 文件中找到。</p>
<pre><code class="language-protobuf">message LogicalPlanNode {
  LogicalPlanNode input = 1;
  FileNode file = 10;
  ProjectionNode projection = 20;
  SelectionNode selection = 21;
  LimitNode limit = 22;
  AggregateNode aggregate = 23;
}

message FileNode {
  string filename = 1;
  Schema schema = 2;
  repeated string projection = 3;
}

message ProjectionNode {
  repeated LogicalExprNode expr = 1;
}

message SelectionNode {
  LogicalExprNode expr = 2;
}

message AggregateNode {
  repeated LogicalExprNode group_expr = 1;
  repeated LogicalExprNode aggr_expr = 2;
}

message LimitNode {
  uint32 limit = 1;
}
</code></pre>
<p>protobuf 项目提供了用于生成特定于语言的源代码以序列化和反序列化数据的工具。</p>
<h2 id="序列化数据"><a class="header" href="#序列化数据">序列化数据</a></h2>
<p>当数据在客户端和执行器之间以及执行器之间传输时，数据也必须被序列化。</p>
<p>Apache Arrow 提供了一个 IPC（进程间通信）格式，用于在进程之间交换数据。由于 Arrow 提供的标准化内存布局，原始字节可以直接在内存与输入/输出设备（磁盘、网络等）之间传输，无需通常与序列化相关联的开销。这实际上是一种零拷贝操作，因为数据不必从其内存中的格式转换为单独的序列化格式。</p>
<p>然而，关于数据的元数据，如 schema（列名和数据类型）确实需要使用 <a href="https://google.github.io/flatbuffers/">Google Flatbuffers</a> 进行编码。这些元数据很小，并且通常每个结果集或每批次只需序列化一次，所以开销很小。</p>
<p>使用 Arrow 的另一个优势是它能够非常高效地在不同编程语言之间交换数据。</p>
<p>Apache Arrow IPC 定义了数据编码格式但没有定义交换机制。例如，Arrow IPC 可以用来通过 JNI 将 JVM 语言中的数据传输到 C 或 Rust。</p>
<h2 id="选择一个协议"><a class="header" href="#选择一个协议">选择一个协议</a></h2>
<p>现在我们已经为查询计划和数据选择了序列化格式，下一个问题是如何在分布式进程之间交换这些数据。</p>
<p>Apache Arrow 提供了一个 <a href="https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/">Flight 协议</a> 专门用于此目的。Flight 是一个新型通用客户端-服务器框架, 旨在简化大型数据库集通过网络接口进行高性能传输。</p>
<p>Arrow Flight 库提供了一个开发框架，用于实现可以发送和接收数据流的服务。 Flight 服务器支持几种基本类型的请求：</p>
<ul>
<li><strong>Handshake</strong>: 一个简单的请求，用于确定客户端是否获得授权，并且在某些情况下，建立一个实现定义的会话令牌以用于将来的请求</li>
<li><strong>ListFlights</strong>: 返回可用数据流的列表</li>
<li><strong>GetSchema</strong>: 返回数据流的结构</li>
<li><strong>GetFlightInfo</strong>: 返回感兴趣的数据集的“访问计划”，可能需要使用多个数据流。此请求可以接受自定义序列化命令，其中包含例如您的特定应用程序参数。</li>
<li><strong>DoGet</strong>: 向客户端发送数据流</li>
<li><strong>DoPut</strong>: 从客户端接收数据流</li>
<li><strong>DoAction</strong>: 执行特定于实现的操作并返回任何结果，即通用函数调用</li>
<li><strong>ListActions</strong>: 返回可用操作类型的列表</li>
</ul>
<p><code>GetFlightInfo</code> 方法可用于编译查询计划并返回接收结果所需的信息，例如，随后调用 <code>DoGet</code> 每个执行器以开始接收查询结果。</p>
<h2 id="流"><a class="header" href="#流">流</a></h2>
<p>重要的是，查询结果可以尽快可用，并流式传输到需要操作该数据的下一个进程，否则会出现不可接受的延迟，因为每个操作都必须等待前一个操作完成。</p>
<p>然而，某些操作要求在产生任何输出之前需要接收所有输入数据。排序操作就是一个很好的例子。在收到整个数据集之前，不可能对数据集进行完全排序。可以通过增加分区数量来缓解该问题，以便对大量分区进行并行排序，然后可以使用合并运算符有效地组合排序后的批次。</p>
<h2 id="自定义代码"><a class="header" href="#自定义代码">自定义代码</a></h2>
<p>通常需要运行自定义代码作为分布式查询或计算的一部分。对于单一语言的查询引擎，通常可以使用该语言内置的序列化机制在查询执行时通过网络传输此代码，这在开发过程中非常方便。另一种方法是将编译后的代码发布到存储库，以便可以在运行时将其下载到集群中。对于基于 JVM 的系统，可以使用 Maven 存储库。更通用的方法是将所有运行时依赖项打包到 Docker 映像中。</p>
<p>查询计划需要提供必要的信息以在运行时加载用户代码。对于基于 JVM 的系统，这可以是类路径和类名。对于基于 C 的系统，这可能是共享对象的路径。无论哪种情况，用户代码都需要实现一些已知的 API。</p>
<h2 id="分布式查询优化"><a class="header" href="#分布式查询优化">分布式查询优化</a></h2>
<p>与单个主机上的并行查询执行相比，分布式查询执行具有大量开销，并且仅应在这样做有好处时才使用. 我推荐阅读论文 <a href="https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf">Scalability! But at what COST</a> 来获取关于这个话题一些有趣视角.</p>
<p>此外，有多种方法可以分发相同的查询，那么我们如何知道使用哪一种呢？</p>
<p>一个答案是建立一种机制来确定执行特定查询计划的成本，然后针对给定问题创建查询计划所有可能组合的某个子集，并确定哪一个最有效。</p>
<p>计算操作成本涉及许多因素，并且涉及不同的资源成本和限制。</p>
<ul>
<li><strong>内存</strong>: 我们通常关心内存的可用性而不是性能。在内存中处理数据比读取和写入磁盘快几个数量级。</li>
<li><strong>CPU</strong>: 对于可并行的工作负载，更多的CPU核心意味着更好的吞吐量。</li>
<li><strong>GPU</strong>: 与 CPU 相比，GPU 上的某些操作要快几个数量级。</li>
<li><strong>磁盘</strong>: 磁盘的读写速度有限，云供应商通常会限制每秒 I/O 操作数 (IOPS)。不同类型的磁盘具有不同的性能特征（HDD、SSD、NVMe）。</li>
<li><strong>网络</strong>: 分布式查询执行涉及节点之间的流数据。网络基础设施存在吞吐量限制。</li>
<li><strong>分布式存储</strong>: 源数据存储在分布式文件系统（HDFS）或对象存储（Amazon S3、Azure Blob 存储）中是很常见的，并且在分布式存储和本地文件系统之间传输数据存在成本。</li>
<li><strong>数据大小</strong>: 数据的大小很重要。当在两个表之间执行联接并且需要通过网络传输数据时，最好传输两个表中较小的一个。如果其中一个表可以容纳在内存中，则可以使用更有效的联表操作。</li>
<li><strong>金钱成本</strong>：果查询的计算速度可以提高 10%，而成本却增加 3 倍，那么值得吗？当然，这是用户最好回答的问题。通常通过限制可用计算资源量来控制金钱成本。</li>
</ul>
<p>如果提前知道有关数据的足够信息，例如数据有多大、查询中使用的联表键分区的基数、分区数量等，则可以使用算法预先计算查询成本。这一切都取决于可用于正在查询的数据集的某些统计数据。</p>
<p>另一种方法是直接开始运行查询并让每个运算符根据其接收到的输入数据进行调整。 Apache Spark 3.0.0 引入了自适应查询执行功能来实现此目的。</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<p>Query engines are complex, and it is easy to inadvertently introduce subtle bugs that could result in queries returning incorrect results, so it is important to have rigorous testing in place.</p>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>An excellent first step is to write unit tests for the individual operators and expressions, asserting that they produce the correct output for a given input. It is also essential to cover error cases.</p>
<p>Here are some suggestions for things to consider when writing unit tests:</p>
<ul>
<li>What happens if an unexpected data type is used? For example, calculating <code>SUM</code> on an input of strings.</li>
<li>Tests should cover edge cases, such as using the minimum and maximum values for numeric data types, and NaN (not a number) for floating point types, to ensure that they are handled correctly.</li>
<li>Tests should exist for underflow and overflow cases. For example, what happens when two long (64-bit) integer types are multiplied?</li>
<li>Tests should also ensure that null values are handled correctly.</li>
</ul>
<p>When writing these tests, it is important to be able to construct record batches and column vectors with arbitrary data to use as inputs for operators and expressions. Here is an example of such a utility method.</p>
<pre><code class="language-kotlin">private fun createRecordBatch(schema: Schema,
                              columns: List&lt;List&lt;Any?&gt;&gt;): RecordBatch {

    val rowCount = columns[0].size
    val root = VectorSchemaRoot.create(schema.toArrow(),
                                       RootAllocator(Long.MAX_VALUE))
    root.allocateNew()
    (0 until rowCount).forEach { row -&gt;
        (0 until columns.size).forEach { col -&gt;
            val v = root.getVector(col)
            val value = columns[col][row]
            when (v) {
                is Float4Vector -&gt; v.set(row, value as Float)
                is Float8Vector -&gt; v.set(row, value as Double)
                ...
            }
        }
    }
    root.rowCount = rowCount

    return RecordBatch(schema, root.fieldVectors.map { ArrowFieldVector(it) })
}
</code></pre>
<p>Here is an example unit test for the "greater than or equals" (<code>&gt;=</code>) expression being evaluated against a record batch containing two columns containing double-precision floating point values.</p>
<pre><code class="language-kotlin">@Test
fun `gteq doubles`() {

    val schema = Schema(listOf(
            Field("a", ArrowTypes.DoubleType),
            Field("b", ArrowTypes.DoubleType)
    ))

    val a: List&lt;Double&gt; = listOf(0.0, 1.0,
                                 Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN)
    val b = a.reversed()

    val batch = createRecordBatch(schema, listOf(a,b))

    val expr = GtEqExpression(ColumnExpression(0), ColumnExpression(1))
    val result = expr.evaluate(batch)

    assertEquals(a.size, result.size())
    (0 until result.size()).forEach {
        assertEquals(if (a[it] &gt;= b[it]) 1 else 0, result.getValue(it))
    }
}
</code></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<p>Once unit tests are in place, the next step is to write integration tests that execute queries consisting of multiple operators and expressions and assert that they produce the expected output.</p>
<p>There are a few popular approaches to integration testing of query engines:</p>
<ul>
<li><strong>Imperative Testing</strong>: Hard-coded queries and expected results, either written as code or stored as files containing the queries and results.</li>
<li><strong>Comparative Testing</strong>: This approach involves executing queries against another (trusted) query engine and asserting that both query engines produced the same results.</li>
<li><strong>Fuzzing</strong>: Generating random operator and expression trees to capture edge cases and get comprehensive test coverage.</li>
</ul>
<h2 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h2>
<p>Much of the complexity of query engines comes from the fact that operators and expressions can be combined through infinite combinations due to the nested nature of operator and expression trees, and it is unlikely that hand-coding test queries will be comprehensive enough.</p>
<p>Fuzzing is a technique for producing random input data. When applied to query engines, this means creating random query plans.</p>
<p>Here is an example of creating random expressions against a DataFrame. This is a recursive method and can produce deeply nested expression trees, so it is important to build in a maximum depth mechanism.</p>
<pre><code class="language-kotlin">fun createExpression(input: DataFrame, depth: Int, maxDepth: Int): LogicalExpr {
    return if (depth == maxDepth) {
        // return a leaf node
        when (rand.nextInt(4)) {
            0 -&gt; ColumnIndex(rand.nextInt(input.schema().fields.size))
            1 -&gt; LiteralDouble(rand.nextDouble())
            2 -&gt; LiteralLong(rand.nextLong())
            3 -&gt; LiteralString(randomString(rand.nextInt(64)))
            else -&gt; throw IllegalStateException()
        }
    } else {
        // binary expressions
        val l = createExpression(input, depth+1, maxDepth)
        val r = createExpression(input, depth+1, maxDepth)
        return when (rand.nextInt(8)) {
            0 -&gt; Eq(l, r)
            1 -&gt; Neq(l, r)
            2 -&gt; Lt(l, r)
            3 -&gt; LtEq(l, r)
            4 -&gt; Gt(l, r)
            5 -&gt; GtEq(l, r)
            6 -&gt; And(l, r)
            7 -&gt; Or(l, r)
            else -&gt; throw IllegalStateException()
        }
    }
}
</code></pre>
<p>Here is example of an expression generated with this method. Note that column references are represented here with an index following a hash, e.g. <code>#1</code> represents column at index 1. This expression is almost certainly invalid (depending on the query engine implementation), and this is to be expected when using a fuzzer. This is still valuable because it will test error conditions that otherwise would not be covered when manually writing tests.</p>
<pre><code>#5 &gt; 0.5459397414890019 &lt; 0.3511239641785846 OR 0.9137719758607572 &gt; -6938650321297559787 &lt; #0 AND #3 &lt; #4 AND 'qn0NN' OR '1gS46UuarGz2CdeYDJDEW3Go6ScMmRhA3NgPJWMpgZCcML1Ped8haRxOkM9F' &gt;= -8765295514236902140 &lt; 4303905842995563233 OR 'IAseGJesQMOI5OG4KrkitichlFduZGtjXoNkVQI0Alaf2ELUTTIci' = 0.857970478666058 &gt;= 0.8618195163699196 &lt;= '9jaFR2kDX88qrKCh2BSArLq517cR8u2' OR 0.28624225053564 &lt;= 0.6363627130199404 &gt; 0.19648131921514966 &gt;= -567468767705106376 &lt;= #0 AND 0.6582592932801918 = 'OtJ0ryPUeSJCcMnaLngBDBfIpJ9SbPb6hC5nWqeAP1rWbozfkPjcKdaelzc' &gt;= #0 &gt;= -2876541212976899342 = #4 &gt;= -3694865812331663204 = 'gWkQLswcU' != #3 &gt; 'XiXzKNrwrWnQmr3JYojCVuncW9YaeFc' &gt;= 0.5123788261193981 &gt;= #2
</code></pre>
<p>A similar approach can be taken when creating logical query plans.</p>
<pre><code class="language-kotlin">fun createPlan(input: DataFrame,
               depth: Int,
               maxDepth: Int,
               maxExprDepth: Int): DataFrame {

    return if (depth == maxDepth) {
        input
    } else {
        // recursively create an input plan
        val child = createPlan(input, depth+1, maxDepth, maxExprDepth)
        // apply a transformation to the plan
        when (rand.nextInt(2)) {
            0 -&gt; {
                val exprCount = 1.rangeTo(rand.nextInt(1, 5))
                child.project(exprCount.map {
                    createExpression(child, 0, maxExprDepth)
                })
            }
            1 -&gt; child.filter(createExpression(input, 0, maxExprDepth))
            else -&gt; throw IllegalStateException()
        }
    }
}
</code></pre>
<p>Here is an example of a logical query plan produced by this code.</p>
<pre><code>Filter: 'VejBmVBpYp7gHxHIUB6UcGx' OR 0.7762591612853446
  Filter: 'vHGbOKKqR' &lt;= 0.41876514212913307
    Filter: 0.9835090312561898 &lt;= 3342229749483308391
      Filter: -5182478750208008322 &lt; -8012833501302297790
        Filter: 0.3985688976088563 AND #1
          Filter: #5 OR 'WkaZ54spnoI4MBtFpQaQgk'
            Scan: employee.csv; projection=None
</code></pre>
<p>This straightforward approach to fuzzing will produce a high percentage of invalid plans. It could be improved to reduce the risk of creating invalid logical plans and expressions by adding more contextual awareness. For example, generating an <code>AND</code> expression could generate left and right expressions that produce a Boolean result. However, there is a danger in only creating correct plans because it could limit the test coverage. Ideally, it should be possible to configure the fuzzer with rules for producing query plans with different characteristics.</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h1>
<p>Each query engine is unique in terms of performance, scalability, and resource requirements, often with different trade-offs. It is important to have good benchmarks to understand the performance and scalability characteristics.</p>
<h2 id="measuring-performance"><a class="header" href="#measuring-performance">Measuring Performance</a></h2>
<p>Performance is often the simplest characteristic to measure and usually refers to the time it takes to perform a particular operation. For example, benchmarks can be built to measure the performance of specific queries or categories of query.</p>
<p>Performance tests typically involve executing a query multiple times and measuring elapsed time.</p>
<h2 id="measuring-scalability"><a class="header" href="#measuring-scalability">Measuring Scalability</a></h2>
<p>Scalability can be an overloaded term and there are many different types of scalability. The term scalability generally refers to how performance varies with different values for some variable that affects performance.</p>
<p>One example would be measuring scalability as total data size increases to discover how performance is impacted, when querying 10 GB of data versus 100 GB or 1 TB. A common goal is to demonstrate linear scalability, meaning that querying 100 GB of data should take 10 times as long as querying 10 GB of data. Linear scalability makes it easy for users to reason about expected behavior.</p>
<p>Other examples of variables that affect performance are:</p>
<ul>
<li>Number of concurrent users, requests, or queries.</li>
<li>Number of data partitions.</li>
<li>Number of physical disks.</li>
<li>Number of cores.</li>
<li>Number of nodes.</li>
<li>Amount of RAM available.</li>
<li>Type of hardware (Raspberry Pi versus Desktop, for example).</li>
</ul>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<p>When measuring scalability based on number of concurrent requests, we are often more interested in throughput (total number of queries executed per period of time) rather than the duration of individual queries, although we typically would collect that information as well.</p>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<p>Benchmarks are often very time-consuming to run and automation is essential so that the benchmarks can be run often, perhaps once per day or once per week, so that any performance regressions can be caught early.</p>
<p>Automation is also important for ensuring that benchmarks are executed consistently and that results are collected with all relevant details that might be needed when analyzing the results.</p>
<p>Here are some examples of the type of data that should be collected when executing benchmarks:</p>
<h3 id="hardware-configuration"><a class="header" href="#hardware-configuration">Hardware Configuration</a></h3>
<ul>
<li>Type of hardware</li>
<li>Number of CPU cores</li>
<li>Available memory and disk space</li>
<li>Operating system name and version</li>
</ul>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<ul>
<li>Environment variables (being careful not to leak secrets)</li>
</ul>
<h3 id="benchmark-configuration"><a class="header" href="#benchmark-configuration">Benchmark Configuration</a></h3>
<ul>
<li>Version of benchmark software used</li>
<li>Version of software under test</li>
<li>Any configuration parameters or files</li>
<li>Filenames of any data files being queried</li>
<li>Data sizes and checksums for the data files</li>
<li>Details about the query that was executed</li>
</ul>
<h3 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h3>
<ul>
<li>Date/time benchmark was started</li>
<li>Start time and end time for each query</li>
<li>Error information for any failed queries</li>
</ul>
<h2 id="comparing-benchmarks"><a class="header" href="#comparing-benchmarks">Comparing Benchmarks</a></h2>
<p>It is important to compare benchmarks between releases of the software so that changes in performance characteristics are apparent and can be investigated further. Benchmarks produce a lot of data that is often hard to compare manually, so it can be beneficial to build tooling to help with this process.</p>
<p>Rather than comparing two sets of performance data directly, tooling can perform a "diff" of the data and show percentage differences between two or more runs of the same benchmark. It is also useful to be able to produce charts showing multiple benchmark runs.</p>
<h2 id="publishing-benchmark-results"><a class="header" href="#publishing-benchmark-results">Publishing Benchmark Results</a></h2>
<p>Here is an example of some real benchmark results, comparing query execution time for the Rust and JVM executors in Ballista, compared to Apache Spark. Although it is clear from this data that the Rust executor is performing well, the benefit can be expressed much better by producing a chart.</p>
<div class="table-wrapper"><table><thead><tr><th>CPU Cores</th><th>Ballista Rust</th><th>Ballista JVM</th><th>Apache Spark</th></tr></thead><tbody>
<tr><td>3</td><td>21.431</td><td>51.143</td><td>56.557</td></tr>
<tr><td>6</td><td>9.855</td><td>26.002</td><td>30.184</td></tr>
<tr><td>9</td><td>6.51</td><td>24.435</td><td>26.401</td></tr>
<tr><td>12</td><td>5.435</td><td>17.529</td><td>18.281</td></tr>
</tbody></table>
</div>
<p>Rather than chart the query execution times, it is often better to chart the throughput. In this case, throughput in terms of queries per minute can be calculated by dividing 60 seconds by the execution time. If a query takes 5 seconds to execute on a single thread, then it should be possible to run 12 queries per minute.</p>
<p>Here is an example chart showing the scalability of throughput as the number of CPU cores increases.</p>
<p><img src="images/benchmark-result-0.2.5.svg" alt="benchmark result" /></p>
<h2 id="transaction-processing-council-tpc-benchmarks"><a class="header" href="#transaction-processing-council-tpc-benchmarks">Transaction Processing Council (TPC) Benchmarks</a></h2>
<p>The Transaction Processing Council is a consortium of database vendors that collaborate on creating and maintaining various database benchmark suites to allow for fair comparisons between vendor's systems. Current TPC member companies include Microsoft, Oracle, IBM, Hewlett Packard Enterprise, AMD, Intel, and NVIDIA.</p>
<p>The first benchmark, TPC-A, was published in 1989 and other benchmarks have been created since then. TPC-C is a well known OLTP benchmark used when comparing traditional RDBMS databases, and TPC-H (discontinued) and TPC-DS are often used for measuring performance of "Big Data" query engines.</p>
<p>TPC benchmarks are seen as the "gold standard" in the industry and are complex and time consuming to implement fully. Also, results for these benchmarks can only be published by TPC members and only after the benchmarks have been audited by the TPC. Taking TPC-DS as an example, the only companies to have ever published official results at the time of writing are Alibaba.com, H2C, SuperMicro, and Databricks.</p>
<p>However, the TPC has a Fair Use policy that allows non-members to create unofficial benchmarks based on TPC benchmarks, as long as certain conditions are followed, such as prefixing any use of the term TPC with "derived from TPC". For example, "Performance of Query derived from TPC-DS Query 14". TPC Copyright Notice and License Agreements must also be maintained. There are also limitations on the types of metrics that can be published.</p>
<p>Many open source projects simply measure the time to execute individual queries from the TPC benchmark suites and use this as a way to track performance over time and for comparison with other query engines.</p>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更多资源"><a class="header" href="#更多资源">更多资源</a></h1>
<p>我希望你觉得这本书有用，并且您现在对查询引擎的内部结构有更好的了解。如果您认为某些主题没有被充分涵盖，或者根本没有涵盖，我很乐意听到你的想法，以便我考虑在未来的修订中添加额外的内容。</p>
<p>可以在 <a href="https://community.leanpub.com/t/feedback/2160">Leanpub 网站</a> 上的公共论坛上发布反馈，或者通过 twitter 直接给我 <a href="https://twitter.com/andygrove_io">@andygrove_io</a> 留言。</p>
<h2 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h2>
<p>有许多包含查询引擎的开源项目，使用这些项目可以更好的了解这个主题。以下只是流行的开源查询引擎的几个示例。</p>
<ul>
<li>Apache Arrow</li>
<li>Apache Calcite</li>
<li>Apache Drill</li>
<li>Apache Hadoop</li>
<li>Apache Hive</li>
<li>Apache Impala</li>
<li>Apache Spark</li>
<li>Facebook Presto</li>
<li>NVIDIA RAPIDS Accelerator for Apache Spark</li>
</ul>
<h2 id="youtube"><a class="header" href="#youtube">YouTube</a></h2>
<p>我最近才发现 Andy Pavlo 的系列讲座，可以在 YouTube 上找到（<a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjasmrEd2_Yi1deeE360zv5O">here</a>）。这不仅仅涵盖了查询引擎，还广泛地介绍了查询优化和执行方面的内容。强烈推荐观看这些视频。</p>
<h2 id="样本数据"><a class="header" href="#样本数据">样本数据</a></h2>
<p>前面的章节引用了 <a href="https://www1.nyc.gov/site/tlc/about/tlc-trip-record-data.page">纽约市出租车及豪华轿车委员会行程记录数据</a> 数据集。黄色和绿色出租车行程记录包括上车和下车日期/时间、上车和下车地点、行程距离、明细票价、费率类型、付款类型和司机报告的乘客数量的字段。数据以 CSV 格式提供。 KQuery 项目包含用于将这些 CSV 文件转换为 Parquet 格式的源代码。</p>
<p>可以通过网站上的链接或直接从 S3 来下载数据。例如，Linux 或 Mac 上的用户可以通过以下命令使用 <code>curl</code> 或者 <code>wget</code> 下载 Yellow Taxis 2019 年 1 月的数据，还可以创建脚本以根据文件命名规范下载其他文件。</p>
<pre><code>wget https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2019-01.csv
</code></pre>
<p><em>这本书还可通过 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 购买 ePub、MOBI 和 PDF格式版本。</em></p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
